<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamr 1-to-1 Video</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://unpkg.com/@streamr/sdk@latest/dist/streamr-sdk.web.js"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
        }
        video#localVideo { 
            transform: scaleX(-1); 
            -webkit-transform: scaleX(-1); 
        }
        .page { 
            display: none; 
        }
        .active { 
            display: block; 
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .status-dot {
            height: 10px; 
            width: 10px; 
            border-radius: 50%; 
            display: inline-block;
        }
        .dot-green { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .dot-red { background-color: #f87171; box-shadow: 0 0 5px #f87171; }
        .dot-yellow { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        .dot-yellow-flashing { animation: pulse-yellow 1.5s infinite; }

        @keyframes pulse-yellow {
            0% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
            50% { background-color: #a16207; box-shadow: none; }
            100% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        }

        /* --- Styles for Sliders --- */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-moz-range-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            transition: background-color 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            border: none;
            border-radius: 9999px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb { background-color: #d4d4d8; }
        input[type="range"]:hover::-moz-range-thumb { background-color: #d4d4d8; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-zinc-900 text-zinc-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl">

        <!-- Main Menu Page -->
        <div id="menu-page" class="page active">
            <div class="text-center">
                <h1 class="text-4xl md:text-5xl font-bold text-white">
                    Decentralized Stream
                </h1>
                 <h2 class="text-4xl md:text-5xl font-bold text-zinc-400 mb-4">
                    Powered by Streamr
                </h2>
            </div>
            
            <div class="mt-10 bg-zinc-800 border border-zinc-700 rounded-xl p-6 md:p-8">
                <div class="grid md:grid-cols-2 gap-6 text-center">
                    <div class="flex flex-col items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-zinc-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
                        <h3 class="text-xl font-bold text-white mb-4">Broadcast</h3>
                        <button id="go-settings" class="w-full bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Start Broadcasting
                        </button>
                    </div>
                    <div class="flex flex-col items-center">
                       <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-zinc-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                        <h3 class="text-xl font-bold text-white mb-4">Watch</h3>
                        <button id="go-watch" class="w-full bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Watch Stream
                        </button>
                    </div>
                </div>
                 <p id="menu-status" class="text-center text-zinc-500 text-sm mt-6">Connecting to the P2P network...</p>
            </div>
        </div>
        
        <!-- Broadcast Settings Page -->
        <div id="settings-page" class="page">
             <div class="text-center mb-8">
                <h1 class="text-3xl font-bold text-white">Broadcast Settings</h1>
                <p class="text-zinc-400 mt-1">Fine-tune your stream for the best performance.</p>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 rounded-xl p-6 md:p-8 space-y-6 text-left max-w-md mx-auto">
                <div>
                    <label for="camera-select" class="block mb-2 text-sm font-medium text-zinc-300">Camera</label>
                    <select id="camera-select" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5"></select>
                </div>
                <div>
                    <label for="mic-select" class="block mb-2 text-sm font-medium text-zinc-300">Microphone</label>
                    <select id="mic-select" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5"></select>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="resolution-slider" class="text-sm font-medium text-zinc-300">Resolution</label>
                        <span id="resolution-value" class="text-sm font-mono text-zinc-400">640x480</span>
                    </div>
                    <input id="resolution-slider" type="range" min="1" max="3" value="2" step="1">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="bitrate-slider" class="text-sm font-medium text-zinc-300">Bitrate</label>
                        <span id="bitrate-value" class="text-sm font-mono text-zinc-400">500 kbps</span>
                    </div>
                    <input id="bitrate-slider" type="range" min="100" max="2000" value="500" step="50">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="fps-slider" class="text-sm font-medium text-zinc-300">Frame Rate</label>
                        <span id="fps-value" class="text-sm font-mono text-zinc-400">24 FPS</span>
                    </div>
                    <input id="fps-slider" type="range" min="10" max="30" value="24" step="1">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="latency-slider" class="text-sm font-medium text-zinc-300">Latency vs. Stability</label>
                        <span id="latency-value" class="text-sm font-mono text-zinc-400">250 ms</span>
                    </div>
                    <input id="latency-slider" type="range" min="100" max="1000" value="250" step="50">
                </div>
            </div>
            <div class="mt-8 flex justify-center gap-4">
                <button id="back-to-menu-3" class="bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Back</button>
                <button id="start-broadcast-btn" class="bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-2 px-5 rounded-lg transition-colors">Start Broadcasting</button>
            </div>
        </div>

        <!-- Broadcast Page -->
        <div id="broadcast-page" class="page">
             <div class="text-center mb-6">
                <h1 class="text-3xl font-bold text-white">Broadcasting</h1>
                <div id="broadcast-status" class="mt-1 text-zinc-400 text-sm">...</div>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                <video id="localVideo" autoplay playsinline muted class="w-full h-auto bg-black rounded-md"></video>
            </div>
            <button id="back-to-menu-1" class="mt-8 bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Stop and Go Back</button>
        </div>

        <!-- Watch Page -->
        <div id="watch-page" class="page">
            <div class="text-center mb-6">
                 <h1 class="text-3xl font-bold text-white">Watching Stream</h1>
                 <div id="watch-status" class="mt-1 text-zinc-400 text-sm">...</div>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                <div class="relative group">
                    <video id="remoteVideo" autoplay playsinline class="w-full h-auto bg-black rounded-md"></video>
                    <div class="absolute top-2 right-2 bg-zinc-900/50 backdrop-blur-sm rounded-full p-2">
                        <span id="statusDot" class="status-dot dot-red" title="Disconnected"></span>
                    </div>
                    <div class="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                         <button id="fullscreen-btn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Fullscreen">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="mt-4 flex justify-end items-center gap-4 px-2">
                    <div class="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-zinc-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" clip-rule="evenodd" />
                        </svg>
                        <input id="volume-slider" type="range" min="0" max="100" value="100" class="w-24">
                    </div>
                    <button id="back-to-menu-2" class="p-2 rounded-full bg-zinc-700 hover:bg-zinc-600 transition-colors" title="Stop and Go Back">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    function startApp() {
        const STREAM_ID = '0xd5a8024414f59cf0c453c35fc3655a31251645f6/app5';
        const STALE_STREAM_TIMEOUT = 5000;

        // UI Elements
        const pages = {
            menu: document.getElementById('menu-page'),
            settings: document.getElementById('settings-page'),
            broadcast: document.getElementById('broadcast-page'),
            watch: document.getElementById('watch-page'),
        };
        const goSettingsBtn = document.getElementById('go-settings');
        const goWatchBtn = document.getElementById('go-watch');
        const startBroadcastBtn = document.getElementById('start-broadcast-btn');
        const backBtns = [
            document.getElementById('back-to-menu-1'), 
            document.getElementById('back-to-menu-2'),
            document.getElementById('back-to-menu-3'),
        ];
        
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const broadcastStatus = document.getElementById('broadcast-status');
        const watchStatus = document.getElementById('watch-status');
        const statusDot = document.getElementById('statusDot');
        const menuStatus = document.getElementById('menu-status');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        
        const cameraSelect = document.getElementById('camera-select');
        const micSelect = document.getElementById('mic-select');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        const bitrateSlider = document.getElementById('bitrate-slider');
        const bitrateValue = document.getElementById('bitrate-value');
        const fpsSlider = document.getElementById('fps-slider');
        const fpsValue = document.getElementById('fps-value');
        const latencySlider = document.getElementById('latency-slider');
        const latencyValue = document.getElementById('latency-value');
        const volumeSlider = document.getElementById('volume-slider');

        // State Variables
        let streamr;
        let localStream;
        let mediaRecorder;
        let subscription;
        let mediaSource;
        let sourceBuffer;
        const receivedChunksQueue = [];
        let isSourceBufferUpdating = false;
        let isPlayerInitialized = false;
        let metaPublishInterval = null;
        let watcherWorker = null;
        let broadcasterWorker = null;
        let streamHealthCheckInterval = null;
        let lastChunkTimestamp = 0;
        
        const resolutionMap = {
            '1': { width: 320, height: 240, label: '320x240' },
            '2': { width: 640, height: 480, label: '640x480' },
            '3': { width: 1280, height: 720, label: '1280x720' }
        };
        
        function showPage(pageName) {
            Object.values(pages).forEach(p => p.classList.remove('active'));
            pages[pageName].classList.add('active');
        }
        
        async function preConnectStreamr() {
            if (streamr) return;
            try {
                streamr = new window.StreamrClient();
                await streamr.connect();
                menuStatus.textContent = "Ready. Choose an option.";
                goSettingsBtn.disabled = false;
                goWatchBtn.disabled = false;
            } catch (error) {
                console.error('Failed to pre-connect to Streamr:', error);
                menuStatus.textContent = "Error connecting to the network. Please refresh.";
            }
        }

        async function populateDeviceSelectors() {
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                tempStream.getTracks().forEach(track => track.stop());
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                cameraSelect.innerHTML = '';
                micSelect.innerHTML = '';

                devices.filter(d => d.kind === 'videoinput').forEach(d => {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.textContent = d.label || `Camera ${cameraSelect.options.length + 1}`;
                    cameraSelect.appendChild(opt);
                });

                devices.filter(d => d.kind === 'audioinput').forEach(d => {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.textContent = d.label || `Microphone ${micSelect.options.length + 1}`;
                    micSelect.appendChild(opt);
                });
            } catch (err) {
                console.error("Error populating devices:", err);
                alert("Could not access media devices. Please check your browser permissions.");
                showPage('menu');
            }
        }

        function setupBroadcasterWorker() {
            const workerCode = `
                function arrayBufferToBase64(buffer) {
                    let binary = '';
                    const bytes = new Uint8Array(buffer);
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    return self.btoa(binary);
                }

                self.onmessage = (event) => {
                    const { type, chunk } = event.data;
                    chunk.arrayBuffer().then(buffer => {
                        const base64Chunk = arrayBufferToBase64(buffer);
                        self.postMessage({ type, chunk: base64Chunk });
                    });
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            broadcasterWorker = new Worker(URL.createObjectURL(blob));

            broadcasterWorker.onmessage = async (event) => {
                const { type, chunk } = event.data;
                if (!streamr) return;
                try {
                    await streamr.publish(STREAM_ID, { type, chunk });
                    if (type === 'init') {
                        if (metaPublishInterval) clearInterval(metaPublishInterval);
                        metaPublishInterval = setInterval(async () => {
                            if (streamr && chunk) {
                                await streamr.publish(STREAM_ID, { type: 'init', chunk });
                            }
                        }, 10000);
                    }
                } catch (e) { console.error("Failed to publish chunk from worker:", e); }
            };
        }

        async function startBroadcast(settings) {
            showPage('broadcast');
            if (!streamr) {
                broadcastStatus.textContent = 'Connecting to Streamr...';
                await preConnectStreamr();
                if (!streamr) {
                     broadcastStatus.textContent = 'Failed to connect to Streamr.';
                     return;
                }
            }
            
            try {
                const constraints = { 
                    video: { 
                        width: { ideal: settings.width }, height: { ideal: settings.height }, 
                        frameRate: { ideal: settings.fps },
                        deviceId: settings.videoDeviceId ? { exact: settings.videoDeviceId } : undefined
                    }, 
                    audio: {
                        deviceId: settings.audioDeviceId ? { exact: settings.audioDeviceId } : undefined
                    } 
                };
                broadcastStatus.textContent = `Accessing camera (${settings.width}x${settings.height} @ ${settings.fps}fps)...`;
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;
                broadcastStatus.textContent = `Broadcasting (~${settings.bitrate / 1000}kbps)...`;

                setupBroadcasterWorker();
                
                const mediaRecorderOptions = { mimeType: 'video/webm; codecs=vp8,opus', videoBitsPerSecond: settings.bitrate };
                mediaRecorder = new MediaRecorder(localStream, mediaRecorderOptions);
                
                let isFirstChunk = true;

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && broadcasterWorker) {
                        const type = isFirstChunk ? 'init' : 'media';
                        if (isFirstChunk) isFirstChunk = false;
                        broadcasterWorker.postMessage({ type, chunk: event.data });
                    }
                };
                
                mediaRecorder.start(settings.timeslice);

            } catch (error) {
                console.error('Error starting broadcast:', error);
                broadcastStatus.textContent = `Error: ${error.message}`;
            }
        }
        
        function setupWatcherWorker() {
            const workerCode = `
                self.onmessage = (event) => {
                    const { chunk } = event.data;
                    const binary_string = self.atob(chunk);
                    const len = binary_string.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binary_string.charCodeAt(i);
                    }
                    self.postMessage(bytes.buffer, [bytes.buffer]);
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            watcherWorker = new Worker(URL.createObjectURL(blob));
            watcherWorker.onmessage = (event) => {
                receivedChunksQueue.push(event.data);
                processNextChunk();
            };
        }

        function resetPlayerState() {
            console.log("Stream is stale or being reset. Looking for new broadcast...");
            isPlayerInitialized = false;
            
            if (remoteVideo.src) {
                URL.revokeObjectURL(remoteVideo.src);
            }
            setupReceiver();

            sourceBuffer = null;
            receivedChunksQueue.length = 0;
            statusDot.className = 'status-dot dot-yellow';
            statusDot.title = 'Interrupted';
            watchStatus.textContent = 'Stream interrupted. Looking for a new broadcast...';
        }

        async function startWatch() {
            showPage('watch');
            if (!streamr) {
                watchStatus.textContent = 'Connecting to Streamr...';
                await preConnectStreamr();
                 if (!streamr) {
                     watchStatus.textContent = 'Failed to connect to Streamr.';
                     return;
                }
            }
            
            setupReceiver();
            setupWatcherWorker();
            watchStatus.textContent = `Looking for a broadcast...`;

            if (streamHealthCheckInterval) clearInterval(streamHealthCheckInterval);
            streamHealthCheckInterval = setInterval(() => {
                if (isPlayerInitialized && (Date.now() - lastChunkTimestamp > STALE_STREAM_TIMEOUT)) {
                    resetPlayerState();
                }
            }, 2000);

            try {
                subscription = await streamr.subscribe({ id: STREAM_ID }, (message) => {
                    lastChunkTimestamp = Date.now();
                    if (!isPlayerInitialized) {
                        if (message.type === 'init' && message.chunk) {
                            isPlayerInitialized = true;
                            watcherWorker.postMessage({ chunk: message.chunk });
                        }
                        return;
                    }
                    if (message.type === 'media' && message.chunk) {
                        watcherWorker.postMessage({ chunk: message.chunk });
                    }
                });
            } catch (error) {
                console.error('Subscription failed:', error);
                watchStatus.textContent = 'Error subscribing to stream.';
            }
        }

        function setupReceiver() {
            mediaSource = new MediaSource();
            remoteVideo.src = URL.createObjectURL(mediaSource);
            remoteVideo.addEventListener('playing', () => {
                watchStatus.textContent = 'Receiving stream...';
                statusDot.className = 'status-dot dot-green';
            });
            remoteVideo.addEventListener('waiting', () => {
                watchStatus.textContent = 'Buffering...';
                statusDot.className = 'status-dot dot-yellow-flashing';
            });
            mediaSource.addEventListener('sourceopen', () => console.log('MediaSource open.'));
        }
        
        function processNextChunk() {
            if (!mediaSource || mediaSource.readyState !== 'open' || isSourceBufferUpdating || receivedChunksQueue.length === 0) {
                return;
            }

            if (!sourceBuffer) {
                 try {
                    const mimeType = 'video/webm; codecs=vp8,opus';
                    sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                    sourceBuffer.addEventListener('updateend', () => {
                        isSourceBufferUpdating = false;
                        if (remoteVideo.paused) {
                            remoteVideo.play().catch(e => console.warn("Autoplay prevented", e.message));
                        }
                        processNextChunk();
                    });
                    statusDot.className = 'status-dot dot-yellow';
                    watchStatus.textContent = 'Initializing player...';
                 } catch (e) {
                    console.error('Error creating SourceBuffer:', e);
                    watchStatus.textContent = 'Video player error.';
                    return;
                 }
            }

            if (sourceBuffer && !sourceBuffer.updating) {
                isSourceBufferUpdating = true;
                try {
                    sourceBuffer.appendBuffer(receivedChunksQueue.shift());
                } catch (e) {
                    console.error("Error appending buffer:", e);
                    isSourceBufferUpdating = false;
                }
            }
        }
        
        async function goBackToMenu() {
            if (metaPublishInterval) clearInterval(metaPublishInterval);
            if (streamHealthCheckInterval) clearInterval(streamHealthCheckInterval);
            
            if (broadcasterWorker) broadcasterWorker.terminate();
            if (localStream) localStream.getTracks().forEach(track => track.stop());

            if (subscription) await subscription.unsubscribe();
            if (watcherWorker) watcherWorker.terminate();
            
            if (mediaSource && mediaSource.readyState === 'open') {
                 try {
                    if (sourceBuffer && sourceBuffer.updating) sourceBuffer.abort();
                    mediaSource.endOfStream();
                } catch (e) { console.warn("Error closing MediaSource:", e.message); }
            }
            remoteVideo.src = '';
            
            // Do not destroy streamr client on back, only on page unload
            
            // Reset state variables
            localStream = null; subscription = null; mediaSource = null;
            sourceBuffer = null; isSourceBufferUpdating = false; isPlayerInitialized = false;
            metaPublishInterval = null; watcherWorker = null; broadcasterWorker = null;
            streamHealthCheckInterval = null; lastChunkTimestamp = 0;
            receivedChunksQueue.length = 0;
            statusDot.className = 'status-dot dot-red';
            showPage('menu');
        }

        // --- Event Listeners ---
        goSettingsBtn.onclick = async () => {
            await populateDeviceSelectors();
            showPage('settings');
        };
        goWatchBtn.onclick = startWatch;
        
        startBroadcastBtn.onclick = () => {
            const resolution = resolutionMap[resolutionSlider.value];
            const settings = {
                width: resolution.width,
                height: resolution.height,
                bitrate: parseInt(bitrateSlider.value, 10) * 1000,
                fps: parseInt(fpsSlider.value, 10),
                timeslice: parseInt(latencySlider.value, 10),
                videoDeviceId: cameraSelect.value,
                audioDeviceId: micSelect.value
            };
            startBroadcast(settings);
        };

        fullscreenBtn.onclick = () => {
            if (remoteVideo.requestFullscreen) {
                remoteVideo.requestFullscreen();
            } else if (remoteVideo.webkitRequestFullscreen) { /* Safari */
                remoteVideo.webkitRequestFullscreen();
            } else if (remoteVideo.msRequestFullscreen) { /* IE11 */
                remoteVideo.msRequestFullscreen();
            }
        };
        
        resolutionSlider.addEventListener('input', (e) => {
            resolutionValue.textContent = resolutionMap[e.target.value].label;
        });
        bitrateSlider.addEventListener('input', (e) => {
            const kbps = e.target.value;
            bitrateValue.textContent = (kbps < 1000) ? `${kbps} kbps` : `${(kbps / 1000).toFixed(1)} Mbps`;
        });
        fpsSlider.addEventListener('input', (e) => {
            fpsValue.textContent = `${e.target.value} FPS`;
        });
        latencySlider.addEventListener('input', (e) => {
            latencyValue.textContent = `${e.target.value} ms`;
        });
        volumeSlider.oninput = (e) => {
            remoteVideo.volume = e.target.value / 100;
        };
        backBtns.forEach(btn => btn.onclick = goBackToMenu);

        preConnectStreamr();
    }
    
    function checkStreamrLibrary() {
        if (window.StreamrClient && window.ethers) {
            console.log("Streamr SDK and Ethers.js loaded.");
            startApp();
        } else {
            console.log("Waiting for Streamr SDK and Ethers.js... Retrying in 100ms.");
            setTimeout(checkStreamrLibrary, 100);
        }
    }

    window.onload = checkStreamrLibrary;
    </script>
</body>
</html>
