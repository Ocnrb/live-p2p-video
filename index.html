<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamr Video Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://unpkg.com/@streamr/sdk@latest/dist/streamr-sdk.web.js"></script>
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
        }
        .status-dot {
            height: 10px; 
            width: 10px; 
            border-radius: 50%; 
            display: inline-block;
        }
        .dot-green { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .dot-red { background-color: #f87171; box-shadow: 0 0 5px #f87171; }
        .dot-yellow { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-moz-range-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            transition: background-color 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            border: none;
            border-radius: 9999px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb { background-color: #d4d4d8; }
        input[type="range"]:hover::-moz-range-thumb { background-color: #d4d4d8; }

        .log-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            background-color: #1a1a1a;
            border: 1px solid #3f3f46;
            border-radius: 12px;
            z-index: 100;
            overflow: hidden;
            flex-direction: column;
        }
        .log-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .log-modal-header {
            padding: 16px 24px;
            border-bottom: 1px solid #3f3f46;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .log-line {
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-bottom: 4px;
        }
        .log-line.info { color: #818cf8; }
        .log-line.success { color: #4ade80; }
        .log-line.error { color: #f87171; }
        .log-line.warning { color: #facc15; }
        
        .play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.6);
            border-radius: 50%;
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .play-button:hover {
            background-color: rgba(0,0,0,0.8);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-zinc-900 text-zinc-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl">
        <div id="watch-page">
            <div class="text-center mb-6">
                 <h1 class="text-3xl font-bold text-white">Decentralized Video Player</h1>
                 <div id="watch-status" class="mt-1 text-zinc-400 text-sm">Connecting to the P2P network...</div>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                <div class="relative group">
                    <video id="remoteVideo" autoplay playsinline muted class="w-full h-auto bg-black rounded-md"></video>
                    <button id="play-button" class="play-button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-white" viewBox="0 0 20 20" fill="currentColor">
                          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div class="absolute top-2 right-2 bg-zinc-900/50 backdrop-blur-sm rounded-full p-2">
                        <span id="statusDot" class="status-dot dot-red" title="Disconnected"></span>
                    </div>
                    <div class="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                         <button id="fullscreen-btn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Fullscreen">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="mt-4 flex justify-end items-center gap-4 px-2">
                    <div class="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-zinc-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.343 5.657 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" clip-rule="evenodd" />
                        </svg>
                        <input id="volume-slider" type="range" min="0" max="100" value="100" class="w-24">
                    </div>
                    <button id="show-logs-btn" class="bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Show Logs</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="log-modal" class="log-modal">
        <div class="log-modal-header">
            <h3 class="text-white font-bold text-lg">Player Logs</h3>
            <button id="close-logs-btn" class="text-zinc-400 hover:text-white transition-colors">&times;</button>
        </div>
        <div class="log-modal-content" id="log-content"></div>
    </div>

    <script>
    function startApp() {
        // Streamr Stream IDs
        const METADATA_STREAM_ID = '0xd5a8024414f59cf0c453c35fc3655a31251645f6/app6';
        const VIDEO_STREAM_ID = '0xd5a8024414f59cf0c453c35fc3655a31251645f6/app5';
        const STALE_STREAM_TIMEOUT = 5000;

        // UI Elements
        const remoteVideo = document.getElementById('remoteVideo');
        const watchStatus = document.getElementById('watch-status');
        const statusDot = document.getElementById('statusDot');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const playButton = document.getElementById('play-button');
        const volumeSlider = document.getElementById('volume-slider');
        const showLogsBtn = document.getElementById('show-logs-btn');
        const closeLogsBtn = document.getElementById('close-logs-btn');
        const logModal = document.getElementById('log-modal');
        const logContent = document.getElementById('log-content');

        // State Variables
        let streamr;
        let metadataSubscription;
        let videoSubscription;
        let mediaSource;
        let sourceBuffer;
        const receivedChunksQueue = [];
        let isSourceBufferUpdating = false;
        let isPlayerInitialized = false;
        let streamHealthCheckInterval = null;
        let lastHeartbeatTimestamp = 0;
        let latestInitChunk = null;
        let playerSessionId = 0;
        let isResetting = false;
        
        function logMessage(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logLine = document.createElement('div');
            logLine.textContent = `[${timestamp}] ${message}`;
            logLine.className = `log-line ${type}`;
            logContent.appendChild(logLine);
            logContent.scrollTop = logContent.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }
        
        function base64ToBuffer(b64) {
            let base64 = b64.replace(/-/g, '+').replace(/_/g, '/');
            const padding = base64.length % 4;
            if (padding) {
                base64 += '===='.slice(padding);
            }
            try {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (e) {
                console.error("Fatal error decoding Base64:", e, "Received string (first 100 characters):", b64.substring(0, 100));
                throw e;
            }
        }

        function setupMediaSource(initBuffer, sessionId) {
            if (mediaSource) return;

            receivedChunksQueue.push(initBuffer);
            mediaSource = new MediaSource();
            remoteVideo.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', () => {
                logMessage(`[Session ${sessionId}] MediaSource 'sourceopen' event fired.`);
                try {
                    const mimeType = 'video/webm; codecs=vp8,opus';
                    sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                    logMessage(`[Session ${sessionId}] SourceBuffer created successfully.`, "success");
                    
                    sourceBuffer.addEventListener('updateend', async () => {
                        isSourceBufferUpdating = false;

                        if (!videoSubscription) {
                            logMessage(`[Session ${sessionId}] Player initialized. Subscribing to video stream...`, "info");
                            videoSubscription = await streamr.subscribe({ id: VIDEO_STREAM_ID }, (videoMessage) => {
                                if (playerSessionId !== sessionId) return; 
                                try {
                                    const buffer = base64ToBuffer(videoMessage.chunk);
                                    receivedChunksQueue.push(buffer);
                                    processNextChunk(sessionId);
                                } catch (e) {
                                    logMessage(`[Session ${sessionId}] Failed to decode video chunk: ${e.message}`, 'error');
                                }
                            });
                        }
                        processNextChunk(sessionId);
                    });
                    
                    sourceBuffer.addEventListener('error', (e) => {
                        if (isResetting) return;
                        isResetting = true;
                        logMessage(`[Session ${sessionId}] SourceBuffer error. Clearing... The player will restart on the next segment.`, 'error');
                        resetPlayerState();
                    });
                    
                    processNextChunk(sessionId);
                } catch (e) {
                    logMessage(`[Session ${sessionId}] Error creating SourceBuffer: ${e.message}`, "error");
                }
            });
        }

        function resetPlayerState() {
            logMessage(`Resetting player (terminating session ${playerSessionId})...`, "warning");
            isPlayerInitialized = false;
            if (videoSubscription) {
                videoSubscription.unsubscribe();
                videoSubscription = null;
            }
            
            if (remoteVideo.src) {
                URL.revokeObjectURL(remoteVideo.src);
                remoteVideo.removeAttribute('src');
                remoteVideo.load();
            }
            
            sourceBuffer = null;
            mediaSource = null;
            receivedChunksQueue.length = 0;
            statusDot.className = 'status-dot dot-yellow';
            watchStatus.textContent = 'Stream interrupted. Looking for a new broadcast...';
            playButton.classList.add('hidden');
        }

        function startPlayer() {
            if (isPlayerInitialized || !latestInitChunk) {
                isResetting = false;
                return;
            }

            playerSessionId++; 
            const currentSessionId = playerSessionId;
            isPlayerInitialized = true;
            logMessage(`[Session ${currentSessionId}] Using 'init' chunk to set up the player.`, "success");

            try {
                receivedChunksQueue.length = 0;
                const buffer = base64ToBuffer(latestInitChunk);
                setupMediaSource(buffer, currentSessionId);
                isResetting = false;
            } catch(e) {
                logMessage(`[Session ${currentSessionId}] Failed to decode init chunk: ${e.message}`, 'error');
                isResetting = false;
                resetPlayerState();
            }
        }
        
        function processNextChunk(sessionId) {
            if (isSourceBufferUpdating || receivedChunksQueue.length === 0 || !sourceBuffer || mediaSource.readyState !== 'open') return;
            
            isSourceBufferUpdating = true;
            try {
                const chunk = receivedChunksQueue.shift();
                sourceBuffer.appendBuffer(chunk);
            } catch (e) {
                logMessage(`[Session ${sessionId}] Error appending chunk: ${e.message}. Restarting...`, "error");
                isSourceBufferUpdating = false;
                if (!isResetting) {
                    isResetting = true;
                    resetPlayerState();
                }
            }
        }
        
        async function initialize() {
            logContent.innerHTML = '';
            playerSessionId = 0;
            isResetting = false;
            logMessage("Initializing player.", "info");

            // Start health check to detect stale streams
            if (streamHealthCheckInterval) clearInterval(streamHealthCheckInterval);
            streamHealthCheckInterval = setInterval(() => {
                if (Date.now() - lastHeartbeatTimestamp > STALE_STREAM_TIMEOUT) {
                    if (isPlayerInitialized) {
                       resetPlayerState();
                    }
                    statusDot.className = 'status-dot dot-red';
                }
            }, 2000);

            // Connect to Streamr network and subscribe to metadata
            try {
                logMessage("Connecting to the Streamr network...");
                streamr = new window.StreamrClient();
                await streamr.connect();
                
                watchStatus.textContent = 'Looking for a broadcast...';
                logMessage("Connected. Subscribing to metadata stream...", "success");

                metadataSubscription = await streamr.subscribe({ id: METADATA_STREAM_ID }, (message) => {
                    lastHeartbeatTimestamp = Date.now();
                    statusDot.className = 'status-dot dot-green';

                    if (message.type === 'init') {
                        const isNewStream = latestInitChunk !== message.chunk;
                        latestInitChunk = message.chunk;

                        if (isPlayerInitialized && isNewStream) {
                            if (isResetting) return;
                            isResetting = true;
                            logMessage("New stream session detected. Restarting player.", "warning");
                            resetPlayerState();
                            setTimeout(() => {
                                startPlayer();
                            }, 100); 
                        } else if (!isPlayerInitialized) {
                            if (isResetting) return;
                            startPlayer();
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to connect or subscribe:', error);
                watchStatus.textContent = "Error connecting to the network. Please refresh the page.";
                logMessage(`Connection failed: ${error.message}`, "error");
            }
        }

        // --- Event Listeners ---
        fullscreenBtn.onclick = () => {
            if (remoteVideo.requestFullscreen) remoteVideo.requestFullscreen();
        };

        playButton.onclick = () => {
            remoteVideo.muted = false;
            remoteVideo.play();
        };
        
        remoteVideo.onplaying = () => playButton.classList.add('hidden');

        remoteVideo.addEventListener('canplay', () => {
            watchStatus.textContent = 'Stream is playing.';
            const playPromise = remoteVideo.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    if (error.name === 'NotAllowedError') {
                        logMessage("Autoplay blocked. Please click the play button.", "warning");
                        watchStatus.textContent = 'Autoplay blocked. Please click the play button.';
                        playButton.classList.remove('hidden');
                    }
                });
            }
        });

        volumeSlider.oninput = (e) => {
            remoteVideo.volume = e.target.value / 100;
            remoteVideo.muted = remoteVideo.volume === 0;
        };
        
        showLogsBtn.onclick = () => logModal.style.display = 'flex';
        closeLogsBtn.onclick = () => logModal.style.display = 'none';
        
        // Start the application
        initialize();
    }
    
    function checkStreamrLibrary() {
        if (window.StreamrClient && window.ethers) {
            console.log("Streamr SDK and Ethers.js loaded.");
            startApp();
        } else {
            console.log("Waiting for Streamr SDK and Ethers.js... Retrying in 100ms.");
            setTimeout(checkStreamrLibrary, 100);
        }
    }

    window.onload = checkStreamrLibrary;
    </script>
</body>
</html>
