<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://unpkg.com;
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        font-src https://fonts.gstatic.com;
        img-src 'self' data: blob:;
        media-src 'self' blob:;
        worker-src 'self' blob:;
        connect-src 'self' https: wss: data:;
    ">
    <title>Streamr - P2P Video and Chat</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ethers.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" type="application/javascript"></script>
    <!-- DOMPurify for security -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.11/purify.min.js"></script>
    <!-- Streamr Client SDK (Latest Version) -->
    <script src="https://unpkg.com/@streamr/sdk@latest/dist/streamr-sdk.web.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Combined styles from both applications */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #121212;
            color: #e0e0e0;
        }

        /* Video App Styles */
        #localVideo.camera-view { 
            transform: scaleX(-1); 
            -webkit-transform: scaleX(-1); 
        }
        .page { 
            display: none; 
        }
        .active { 
            display: block; 
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .status-dot {
            height: 10px; 
            width: 10px; 
            border-radius: 50%; 
            display: inline-block;
        }
        .dot-green { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .dot-red { background-color: #f87171; box-shadow: 0 0 5px #f87171; }
        .dot-yellow { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        .dot-yellow-flashing { animation: pulse-yellow 1.5s infinite; }
        @keyframes pulse-yellow {
            0% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
            50% { background-color: #a16207; box-shadow: none; }
            100% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer; width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track { background: #3f3f46; height: 0.25rem; border-radius: 0.5rem; }
        input[type="range"]::-moz-range-track { background: #3f3f46; height: 0.25rem; border-radius: 0.5rem; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            margin-top: -6px; background-color: #a1a1aa; height: 1rem;
            width: 1rem; border-radius: 9999px; transition: background-color 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            border: none; border-radius: 9999px; background-color: #a1a1aa;
            height: 1rem; width: 1rem; transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb { background-color: #d4d4d8; }
        input[type="range"]:hover::-moz-range-thumb { background-color: #d4d4d8; }
        .tooltip-container { position: relative; display: inline-flex; align-items: center; }
        .tooltip-icon { margin-left: 8px; cursor: help; }
        .tooltip-text {
            visibility: hidden; width: 220px; background-color: #27272a; color: #d4d4d8;
            text-align: center; border-radius: 6px; padding: 8px; position: absolute;
            z-index: 10; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0;
            transition: opacity 0.3s; font-size: 0.8rem; font-weight: normal;
            border: 1px solid #3f3f46;
        }
        .tooltip-container:hover .tooltip-text { visibility: visible; opacity: 1; }
        #advanced-settings-group summary {
            list-style: none; cursor: pointer; display: flex;
            justify-content: space-between; align-items: center; padding: 0.5rem 0;
        }
        #advanced-settings-group summary::-webkit-details-marker { display: none; }
        #advanced-settings-group .summary-arrow { transition: transform 0.2s; }
        #advanced-settings-group[open] .summary-arrow { transform: rotate(90deg); }
        .stream-item {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #3f3f46;
            transition: background-color 0.2s, transform 0.2s;
            cursor: pointer;
            overflow: hidden;
        }
        .stream-item:hover {
            background-color: #27272a;
            transform: translateY(-2px);
        }
        .go-live-item {
             background: linear-gradient(45deg, #1e3a8a, #3b82f6);
             border: 1px solid #3b82f6;
        }
         .go-live-item:hover {
            background: linear-gradient(45deg, #1e40af, #2563eb);
         }

        /* Chat App Styles (Twitch/YouTube Style) */
        .message-entry {
            animation: fadeIn 0.3s ease-in-out;
            padding: 0.2rem 0.5rem;
            line-height: 1.4;
            word-break: break-word;
        }
        .chat-username {
            font-weight: 600; /* semibold */
            margin-right: 0.5rem; /* space between name and message */
            display: inline;
        }
        .chat-message-text {
            display: inline;
            color: #e0e0e0; /* main text color */
        }
        .tip-notification {
            background-color: rgba(251, 191, 36, 0.1);
            border-left: 3px solid #f59e0b;
            color: #fde68a;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-style: italic;
            font-size: 0.8rem;
            margin: 0.25rem 0;
            line-height: 1.4;
            word-break: break-word;
        }
        .send-button { background-color: #2563eb; color: white; width: 2.5rem; height: 2.5rem; border-radius: 9999px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: background-color 0.2s; }
        .send-button:hover { background-color: #1d4ed8; }
        .emoji-button { background-color: transparent; color: #9ca3af; padding: 0.5rem; border-radius: 9999px; display: flex; align-items: center; justify-content: center; margin-right: 0.5rem; transition: color 0.2s; }
        .emoji-button:hover { color: #fbbf24; }
        .emoji-picker { position: absolute; bottom: 60px; left: 10px; background-color: #1f2937; border: 1px solid #4b5563; border-radius: 0.5rem; padding: 0.5rem; display: flex; flex-wrap: wrap; max-width: 300px; display: none; z-index: 20; }
        .emoji-picker span { cursor: pointer; margin: 2px; font-size: 1.2rem; padding: 4px; border-radius: 4px; transition: background-color 0.2s;}
        .emoji-picker span:hover { background-color: #4b5563; }
        #messagesContainer { scrollbar-width: thin; scrollbar-color: #4b5563 #1f2937; }
        #messageInput, #tipAmountInput, #tipTokenSelect { background-color: #374151; color: #e0e0e0; border: 1px solid #4b5563; }
        
        /* Spinner for login */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #ffffff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Collapsible arrow rotation */
        #toggle-latency-arrow.open {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-zinc-900 text-zinc-300 flex justify-center h-screen p-4">

    <div id="main-container" class="w-full h-full max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-5 gap-8 items-start pt-12 md:pt-16">
        
        <!-- Video Column -->
        <div id="video-column" class="lg:col-span-5 w-full flex justify-center">
             <div class="w-full max-w-4xl">
                
                <!-- Lobby Page (New) -->
                <div id="lobby-page" class="page active">
                    <div class="text-center mb-8">
                        <h1 class="text-3xl font-bold text-white">Stream Rooms</h1>
                        <p id="lobby-status" class="text-zinc-400 mt-1">Loading available rooms...</p>
                    </div>

                    <!-- Go Live Button -->
                    <div class="flex justify-center mb-10">
                         <button id="go-live-btn-lobby" class="go-live-item stream-item w-full max-w-[220px] flex flex-col items-center justify-center p-4">
                             <div class="mb-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path>
                                    <path d="M14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z"></path>
                                </svg>
                            </div>
                            <h2 class="text-md font-semibold text-white">Go Live</h2>
                        </button>
                    </div>

                    <div id="stream-list-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Stream items will be dynamically added here -->
                    </div>
                </div>

                <!-- Broadcast Settings Page -->
                <div id="settings-page" class="page">
                     <div class="text-center mb-8">
                        <h1 class="text-3xl font-bold text-white">Broadcast Settings</h1>
                        <p class="text-zinc-400 mt-1">Fine-tune your stream for the best performance.</p>
                    </div>
                    <div class="bg-zinc-800 border border-zinc-700 rounded-xl p-6 md:p-8 space-y-4 divide-y divide-zinc-700/50 text-left max-w-md mx-auto">
                        <div class="pt-2">
                            <h3 class="text-sm font-medium text-zinc-300 mb-2">Room Name</h3>
                            <input type="text" id="roomNameInput" class="w-full bg-zinc-700 border border-zinc-600 rounded-lg p-2 mb-4 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter a name for your room (max 30 chars)..." maxlength="30">
                        </div>
                        <div class="pt-2">
                            <h3 class="text-sm font-medium text-zinc-300 mb-2">Source</h3>
                            <div class="grid grid-cols-2 gap-2 rounded-lg bg-zinc-700 p-1">
                                <label class="text-center text-sm py-2 rounded-md cursor-pointer transition-colors bg-zinc-600 text-white" for="source-camera">Camera</label>
                                <input type="radio" name="broadcast-source" id="source-camera" value="camera" class="sr-only" checked>
                                <label class="text-center text-sm py-2 rounded-md cursor-pointer transition-colors hover:bg-zinc-600/50" for="source-screen">Screen</label>
                                <input type="radio" name="broadcast-source" id="source-screen" value="screen" class="sr-only">
                            </div>
                        </div>
                        <div id="input-devices-group" class="pt-4 space-y-4">
                            <h3 class="text-sm font-medium text-zinc-300">Input Devices</h3>
                            <div>
                                <label for="videoSourceSelect" class="block mb-2 text-sm font-medium text-zinc-400">Camera</label>
                                <select id="videoSourceSelect" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5 disabled:opacity-50" disabled></select>
                            </div>
                            <div>
                                <label for="audioSourceSelect" class="block mb-2 text-sm font-medium text-zinc-400">Microphone</label>
                                <select id="audioSourceSelect" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5 disabled:opacity-50" disabled></select>
                                <canvas id="audio-meter-canvas" width="300" height="10" class="mt-2 w-full h-2 bg-zinc-700 rounded-full"></canvas>
                            </div>
                        </div>
                        <div id="video-quality-group" class="pt-4 space-y-4">
                            <h3 class="text-sm font-medium text-zinc-300">Video Quality</h3>
                            <div id="resolution-setting">
                                <div class="flex justify-between items-center mb-2">
                                    <label for="resolutionSlider" class="text-sm font-medium text-zinc-400">Resolution</label>
                                    <span id="resolutionValue" class="text-sm font-mono text-zinc-400">720p</span>
                                </div>
                                <input id="resolutionSlider" type="range" min="0" max="2" value="1" step="1" class="disabled:opacity-50">
                            </div>
                             <div id="framerate-setting">
                                <div class="flex justify-between items-center mb-2">
                                    <label for="framerateSlider" class="text-sm font-medium text-zinc-400">Frame Rate</label>
                                    <span id="framerateValue" class="text-sm font-mono text-zinc-400">30 fps</span>
                                </div>
                                <input id="framerateSlider" type="range" min="15" max="60" value="30" step="1" class="disabled:opacity-50">
                            </div>
                            <div>
                                <div class="flex justify-between items-center mb-2">
                                    <label for="bitrateSlider" class="text-sm font-medium text-zinc-400">Video Bitrate</label>
                                    <span id="bitrateValue" class="text-sm font-mono text-zinc-400">2.0 Mbps</span>
                                </div>
                                <input id="bitrateSlider" type="range" min="500000" max="12000000" value="2000000" step="100000" class="disabled:opacity-50">
                            </div>
                        </div>
                        <div id="audio-quality-group" class="pt-4 space-y-4">
                             <h3 class="text-sm font-medium text-zinc-300">Audio Quality</h3>
                             <div>
                                <div class="flex justify-between items-center mb-2">
                                     <label for="audioQualitySlider" class="text-sm font-medium text-zinc-400">Quality</label>
                                     <span id="audioQualityValue" class="text-sm font-mono text-zinc-400">Balanced (64 Kb)</span>
                                </div>
                                <input id="audioQualitySlider" type="range" min="0" max="3" value="1" step="1" class="disabled:opacity-50">
                            </div>
                        </div>
                        <details id="advanced-settings-group" class="pt-2">
                            <summary class="text-sm font-medium text-zinc-300">
                                <span>Advanced Settings</span>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 summary-arrow text-zinc-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                                </svg>
                            </summary>
                            <div class="space-y-4 pt-4">
                                <div>
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="tooltip-container">
                                            <label for="performanceSlider" class="text-sm font-medium text-zinc-400">Performance</label>
                                            <div class="tooltip-icon">
                                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-zinc-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></svg>
                                            </div>
                                            <span class="tooltip-text !w-56 !-ml-28">Lowest Latency is faster for real-time interaction. Best Quality prioritizes a clearer image, which might add a small delay.</span>
                                        </div>
                                        <span id="performanceValue" class="text-sm font-mono text-zinc-400">Lowest Latency</span>
                                    </div>
                                    <input id="performanceSlider" type="range" min="0" max="1" value="0" step="1" class="disabled:opacity-50">
                                </div>
                                <div>
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="tooltip-container">
                                            <label for="keyframeIntervalSlider" class="text-sm font-medium text-zinc-400">Key Frame Interval</label>
                                             <div class="tooltip-icon">
                                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-zinc-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></svg>
                                            </div>
                                            <span class="tooltip-text !w-56 !-ml-28">How often a full video frame is sent. Shorter intervals can improve stream recovery on unstable connections but use more data.</span>
                                        </div>
                                        <span id="keyframeIntervalValue" class="text-sm font-mono text-zinc-400">2.0 s</span>
                                    </div>
                                    <input id="keyframeIntervalSlider" type="range" min="1000" max="10000" value="2000" step="500" class="disabled:opacity-50">
                                </div>
                            </div>
                        </details>
                    </div>
                    <p id="settings-status" class="text-center text-red-400 text-sm mt-4 min-h-[1.25rem]"></p>
                    <div class="mt-4 flex justify-center gap-4">
                        <button id="back-to-lobby-btn-settings" class="bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Back</button>
                        <button id="start-broadcast-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-5 rounded-lg transition-colors">Start Broadcasting</button>
                    </div>
                </div>

                <!-- Broadcast Page -->
                <div id="broadcast-page" class="page">
                     <h1 class="text-2xl font-bold text-white text-center mb-1">Broadcasting</h1>
                     <div id="broadcast-room-info" class="text-center text-zinc-400 mb-4 flex items-center justify-center gap-2">
                        <span id="roomNameOnBroadcastPage" class="font-semibold"></span>
                        <button id="shareBtnBroadcast" title="Copy room link" class="text-zinc-400 hover:text-white transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                            </svg>
                        </button>
                     </div>
                     <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                        <div class="flex items-center justify-between text-zinc-400 text-sm mb-4">
                            <!-- Left side: User ID -->
                            <div class="flex items-center gap-2">
                                 <span id="broadcaster-user-id" class="text-xs truncate"></span>
                                 <button id="nicknameBtnBroadcast" title="Set Nickname" class="text-zinc-400 hover:text-white transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <!-- Right side: Status -->
                            <div class="flex items-center gap-4">
                                <div id="broadcast-status">...</div>
                                <div id="viewer-count-broadcaster" class="flex items-center gap-1 hidden">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                                    <span id="viewer-count-broadcaster-value">0</span>
                                </div>
                            </div>
                        </div>
                        <video id="localVideo" autoplay playsinline muted class="w-full h-auto bg-zinc-900 rounded-md camera-view"></video>
                    </div>
                    <div class="w-full flex justify-center">
                        <button id="back-to-lobby-btn" class="mt-8 bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Stop and Go Back</button>
                    </div>
                </div>

                <!-- Watch Page -->
                <div id="watch-page" class="page">
                    <!-- Player Header: Contains all metadata about the stream -->
                    <div id="player-header" class="text-center mb-6">
                        <div class="text-2xl font-bold text-white flex items-center justify-center gap-2">
                             <h1 id="roomNameOnWatchPage">Watching Stream</h1>
                             <button id="shareBtnWatch" title="Copy room link" class="text-zinc-400 hover:text-white transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                                </svg>
                             </button>
                        </div>
                        <div id="broadcaster-info-on-watch-page" class="text-zinc-400 text-sm mt-2 hidden flex items-center justify-center gap-2">
                             <span id="broadcaster-display-name"></span>
                             <div class="tooltip-container">
                                <button id="tipBtn" class="ml-2 bg-amber-500 hover:bg-amber-600 text-white font-bold py-1 px-2 rounded-full text-xs transition-colors flex items-center gap-1 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-amber-500">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                      <path d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.5 2.5 0 00-1.134 0V7.418zM12.25 10a2.5 2.5 0 01-2.25 2.45V15a.75.75 0 01-1.5 0v-2.55a2.5 2.5 0 01-2.25-2.45V9a.75.75 0 011.5 0v1h.75a.75.75 0 010 1.5H9.5v-1a.75.75 0 011.5 0v1h.75a.75.75 0 010 1.5H11v-1a.75.75 0 011.5 0V10z" />
                                      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-1.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z" clip-rule="evenodd" />
                                    </svg>
                                    <span>Tip</span>
                                </button>
                                <span class="tooltip-text !w-64 !-ml-32">To send a tip, both you and the broadcaster must be connected with a wallet.</span>
                             </div>
                        </div>
                        <div class="flex items-center justify-center gap-4 mt-1 text-zinc-400 text-sm">
                            <div id="watch-status">...</div>
                            <div id="viewer-count-watcher" class="flex items-center gap-1 hidden">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                                <span id="viewer-count-watcher-value">0</span>
                            </div>
                        </div>
                    </div>

                    <!-- Player Container: Wraps the video canvas and its overlay controls -->
                    <div id="player-container" class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                        <div class="relative group">
                            <div id="canvas-wrapper" class="w-full bg-zinc-900 rounded-md overflow-hidden">
                                <canvas id="remoteCanvas" class="w-full h-full block"></canvas>
                            </div>
                            <div class="absolute top-2 right-2 bg-zinc-900/50 backdrop-blur-sm rounded-full p-2">
                                <span id="statusDot" class="status-dot dot-red" title="Disconnected"></span>
                            </div>
                             <div class="absolute bottom-4 left-4 right-4 flex justify-between items-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <button id="back-to-lobby-btn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Stop and Go Back">
                                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                                <button id="playPauseBtn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Play/Pause">
                                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white hidden" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                                    </svg>
                                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                </button>
                                <div class="flex items-center gap-2 w-24">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-zinc-400" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" clip-rule="evenodd" />
                                    </svg>
                                    <input id="volume-slider" type="range" min="0" max="100" value="100" class="w-full">
                                </div>
                                 <button id="fullscreen-btn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Fullscreen">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Player Footer: Contains external controls like the buffer slider -->
                    <div id="player-footer" class="mt-4 flex flex-col items-center gap-2 px-2">
                         <button id="toggle-latency-controls-btn" class="p-2 rounded-full hover:bg-zinc-700 transition-colors">
                            <svg id="toggle-latency-arrow" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-zinc-400 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                        <div id="latency-controls-collapsible" class="w-full hidden">
                            <div class="space-y-2">
                                <div id="latency-controls">
                                    <label for="bufferSlider" class="text-sm font-medium text-zinc-300 text-center block mb-2">Playback Buffer</label>
                                    <div id="buffer-slider-container" class="flex items-center gap-3">
                                        <span class="text-xs text-zinc-400">Fastest</span>
                                        <input id="bufferSlider" type="range" min="150" max="3000" value="150" step="50">
                                        <span class="text-xs text-zinc-400">Smoothest</span>
                                    </div>
                                    <span id="bufferValue" class="text-sm font-mono text-zinc-400 text-center block mt-1">150 ms (Lowest Latency)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Column -->
        <div id="chat-container" class="lg:col-span-2 w-full hidden">
            <div class="bg-zinc-800 border border-zinc-700 w-full rounded-xl shadow-2xl flex flex-col">
                <div class="p-4 flex flex-col flex-1 h-0">
                    <div id="chat-header" class="flex justify-between items-center pb-2 mb-2 border-b border-zinc-700">
                        <span id="chat-user-id" class="text-xs text-zinc-400 truncate"></span>
                        <button id="nicknameBtn" title="Set Nickname" class="text-zinc-400 hover:text-white transition-colors">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <div class="flex-1 mb-4 overflow-y-auto p-2 rounded-lg bg-zinc-900 flex flex-col" id="messagesContainer"></div>
                    <div class="relative flex items-center mt-auto">
                        <button id="emojiBtn" class="emoji-button">😀</button>
                        <div id="emojiPicker" class="emoji-picker overflow-y-auto max-h-64"></div>
                        <textarea id="messageInput" rows="1" placeholder="Write your message..." class="flex-1 py-2 px-4 pr-16 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"></textarea>
                        <button id="sendBtn" class="send-button absolute right-2 top-1/2 -translate-y-1/2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModal" class="fixed inset-0 bg-zinc-900 flex items-center justify-center p-4 z-50">
        <div class="bg-zinc-800 border border-zinc-700 rounded-lg p-8 max-w-sm w-full text-zinc-300 text-center shadow-2xl">
            <div id="loginContent">
                <h2 class="text-2xl font-bold mb-4 text-white">Welcome to Decentralized Streaming Platform</h2>
                <p class="mb-6">For a persistent identity, connect your wallet. Otherwise, you can continue as a guest.</p>
                <button id="connectWalletBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors mb-4 flex items-center justify-center gap-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path></svg>
                    Connect Wallet
                </button>
                <button id="guestBtn" class="w-full bg-zinc-600 hover:bg-zinc-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Continue as Guest
                </button>
            </div>
            <div id="loadingContent" class="hidden">
                 <div class="flex justify-center items-center mb-4">
                    <div class="spinner"></div>
                </div>
                <p class="text-lg">Connecting...</p>
                <p id="loading-instructions" class="text-sm text-zinc-400 mt-2"></p>
            </div>
        </div>
    </div>
    
    <!-- Nickname Modal -->
    <div id="nicknameModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-zinc-800 rounded-lg p-8 max-w-sm w-full text-zinc-300 border border-zinc-700">
            <h2 class="text-2xl font-bold mb-4 text-white">Set Your Nickname</h2>
            <p class="mb-4">This will be displayed to other users in the chat.</p>
            <input type="text" id="nicknameInput" class="w-full bg-zinc-700 border border-zinc-600 rounded-lg p-2 mb-4 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your nickname..." maxlength="20">
            
            <div class="flex items-center gap-4">
                <button id="saveNicknameBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Save Nickname">
                    Save
                </button>
                <button id="resetNicknameBtn" class="w-full bg-zinc-600 hover:bg-zinc-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Reset to ID">
                    Reset
                </button>
            </div>
        </div>
    </div>

    <!-- Tip Modal -->
    <div id="tipModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-zinc-800 rounded-lg p-8 max-w-sm w-full text-zinc-300 border border-zinc-700">
            <div id="tip-initial-view">
                <h2 class="text-2xl font-bold mb-2 text-white">Send a Tip</h2>
                <p class="mb-4">Show your support for <span id="tip-recipient-name" class="font-semibold">the broadcaster</span>!</p>
                <div class="mb-4 space-y-3">
                    <div>
                        <label for="tipTokenSelect" class="block text-sm font-medium text-zinc-400 mb-1">Token</label>
                        <select id="tipTokenSelect" class="w-full bg-zinc-700 border border-zinc-600 rounded-lg p-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                    </div>
                    <div>
                        <label for="tipAmountInput" id="tipAmountLabel" class="block text-sm font-medium text-zinc-400 mb-1">Amount</label>
                        <input type="number" id="tipAmountInput" step="0.001" min="0" class="w-full bg-zinc-700 border border-zinc-600 rounded-lg p-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="0.01">
                    </div>
                </div>
                <p id="tip-error-msg" class="text-red-400 text-sm mb-4 min-h-[1.25rem]"></p>
                <div class="flex items-center gap-4">
                    <button id="cancelTipBtn" class="w-full bg-zinc-600 hover:bg-zinc-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        Cancel
                    </button>
                    <button id="sendTipBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        Send Tip
                    </button>
                </div>
            </div>
            <div id="tip-loading-view" class="hidden text-center">
                <div class="flex justify-center items-center mb-4">
                    <div class="spinner"></div>
                </div>
                <p class="text-lg">Processing Transaction...</p>
                <p class="text-sm text-zinc-400 mt-2">Please confirm in your wallet.</p>
            </div>
            <div id="tip-success-view" class="hidden text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-green-400 mx-auto mb-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                </svg>
                <h2 class="text-2xl font-bold mb-2 text-white">Success!</h2>
                <p class="mb-4">Your tip has been sent.</p>
                <a id="tip-etherscan-link" href="#" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline mb-4 inline-block">View on Explorer</a>
                <button id="closeTipSuccessBtn" class="w-full bg-zinc-600 hover:bg-zinc-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-5 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300">
        Link copied to clipboard!
    </div>

    <script>
        // --- Stream Constants ---
        const LOBBY_STREAM_ID = '0x9b365dd30a9a15bf4b4c6814970290ea7fbd6e4b/lobby';
        const VIDEO_STREAM_BASE = '0x9b365dd30a9a15bf4b4c6814970290ea7fbd6e4b/app1';
        const AUDIO_STREAM_BASE = '0x9b365dd30a9a15bf4b4c6814970290ea7fbd6e4b/app2';
        const PRESENCE_STREAM_BASE = '0x9b365dd30a9a15bf4b4c6814970290ea7fbd6e4b/app3';
        const CHAT_STREAM_BASE = '0x9b365dd30a9a15bf4b4c6814970290ea7fbd6e4b/app4';
        const PARTITIONS = 99; // Total number of available partitions
        const MAX_MESSAGES = 100;
        const LIVE_BUFFER_TARGET_MS = 250; // Increased for audio stability

        // --- UI Element Variables (declared here, assigned in main) ---
        let mainContainer, videoColumn, pages, startBroadcastBtn, backBtns, localVideo, remoteCanvas,
            canvasWrapper, broadcastStatus, watchStatus, statusDot, fullscreenBtn, playPauseBtn, playIcon, pauseIcon,
            viewerCountBroadcaster, viewerCountBroadcasterValue, viewerCountWatcher, viewerCountWatcherValue,
            broadcastSourceRadios, inputDevicesGroup, videoQualityGroup, videoSourceSelect, audioSourceSelect, audioMeterCanvas,
            resolutionSlider, resolutionValue, resolutionSetting, framerateSetting, bitrateSlider, bitrateValue, framerateSlider,
            framerateValue, audioQualitySlider, audioQualityValue, performanceSlider, performanceValue, keyframeIntervalSlider,
            keyframeIntervalValue, volumeSlider, bufferSlider, bufferValue, latencyControls, canvasContext, loginModal, loginContent, loadingContent, connectWalletBtn, guestBtn,
            loadingInstructions, chatContainer, messageInput, sendBtn, emojiBtn, messagesContainer, emojiPicker,
            nicknameModal, nicknameInput, saveNicknameBtn, resetNicknameBtn, nicknameBtn, chatUserId, settingsStatus, nicknameBtnBroadcast, broadcasterUserId,
            broadcasterInfoOnWatchPage, toggleLatencyControlsBtn, latencyControlsCollapsible, toggleLatencyArrow, lobbyPage, streamListContainer, lobbyStatus, roomNameOnWatchPage,
            roomNameInput, roomNameOnBroadcastPage, shareBtnBroadcast, shareBtnWatch, toast, goLiveBtnLobby,
            // --- Tipping UI ---
            broadcasterDisplayName, tipBtn, tipModal, tipInitialView, tipLoadingView, tipSuccessView,
            tipRecipientName, tipAmountInput, tipErrorMsg, cancelTipBtn, sendTipBtn, closeTipSuccessBtn, tipEtherscanLink, tipTokenSelect, tipAmountLabel;


        const emojis = [
            '😂', '😭', '❤️', '👍', '👎', '👏', '🔥', '💯', '🤔', '🙏', '🤯', '🥳', '😎', '😀', '😃', '😄', '😁', '😆', '😅', '🤣', '😊', '😇', '🙂', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚',
            '🤩', '🤪', '😜', '😝', '😋', '😛', '🤑', '🤭', '🤫', '😶', '😐', '😑', '😏', '😒', '🙄', '😬', '🤥', '😌', '😔', '😴', '🤤', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '🥵', '🥶', '😵', '🤯', '🤠', '😎', '🤓', '🧐', '😕',
            '😟', '🙁', '☹️', '😮', '😯', '😲', '😳', '🥺', '😦', '😧', '😨', '😩', '😫', '😡', '😠', '🤬', '😈', '👿', '💀', '☠️', '💩', '👻', '👽', '🤖', '👾', '🙈', '🙉', '🙊', '👋', '🤚', '🖐️', '✋', '🖖', '👌', '🤏', '✌️', '🤞', '🤟', '🤘', '🤙', '👈', '👉', '👆', '👇', '☝️', '👍', '👎', '✊', '🤛', '🤜', '👏', '🙌',
            '💪', '✍️', '🙏', '🦶', '🦵', '👂', '👃', '👁️', '👀', '🧠', '👅', '👄', '🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦', '🦉', '🐛', '🦋', '🐢', '🐍', '🐙', '🦑', '🦞', '🦀', '🐠', '🐟', '🐡', '🦈', '🐳', '🐬', '🐾',
            '🍏', '🍎', '🍐', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🍈', '🍒', '🍑', '🥭', '🍍', '🥥', '🥝', '🍅', '🍆', '🥑', '🥦', '🥕', '🥔', '🌶️', '🌽', '🍄', '🥜', '🌰', '🍞', '🥐', '🥖', '🥨', '🥞', '🧇', '🧀', '🍗', '🍖', '🍣', '🍤', '🍙', '🍚', '🍜', '🍲', '🍝', '🍕', '🍔', '🍟', '🌭', '🌮', '🌯', '🥙', '🥪', '🍟', '🍡', '🍦', '🍩', '🍪', '🎂', '🍰', '🍫', '🍬', '🍭', '🍮',
            '⚽', '🏀', '🏈', '⚾', '🥎', '🏐', '🏉', '🎾', '🥏', '🎳', '🏏', '🏑', '🏒', '🥍', '🏓', '🏸', '🥊', '🥋', '🥅', '⛳', '🎯', '🪁', '🎣', '🤿', '🎨', '🎬', '🎤', '🎧', '🎸', '🎹', '🎷', '🎺', '🎻', '🥁', '🎲', '♟️', '🎮', '🕹️',
            '❤️', '🧡', '💛', '💚', '💙', '💜', '🤎', '🖤', '🤍', '💔', '❣️', '💕', '💞', '💓', '💗', '💖', '💘', '💝', '💌', '💥', '💫', '🌟', '✨', '⚡', '🔥', '☄️', '💧', '🌊', '💦', '💧',
            '🎈', '🎉', '🎊', '🎁', '🎀', '🪄', '🔔', '📢', '🔊', '📣', '📯', '🎶', '🎵', '🎼', '🎙️', '📱', '📞', '💻', '🖥️', '⌨️', '🖱️', '🔋', '🔌', '💡', '🔦', '💵', '💰', '💳', '💎'
        ];

        // --- Web3 Constants ---
        const ERC20_ABI = ["function transfer(address to, uint amount) returns (bool)"];
        const NETWORKS = {
            1: { name: 'Ethereum', symbol: 'ETH', explorer: 'https://etherscan.io', rpcUrl: 'https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161' },
            137: { name: 'Polygon', symbol: 'MATIC', explorer: 'https://polygonscan.com', rpcUrl: 'https://polygon-rpc.com' },
            42161: { name: 'Arbitrum', symbol: 'ETH', explorer: 'https://arbiscan.io', rpcUrl: 'https://arb1.arbitrum.io/rpc' },
            10: { name: 'Optimism', symbol: 'ETH', explorer: 'https://optimistic.etherscan.io', rpcUrl: 'https://mainnet.optimism.io' },
            8453: { name: 'Base', symbol: 'ETH', explorer: 'https://basescan.org', rpcUrl: 'https://mainnet.base.org' },
        };
        const TOKEN_ADDRESSES = {
            1: { // Ethereum
                'USDC': '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
                'USDT': '0xdAC17F958D2ee523a2206206994597C13D831ec7',
                'DATA': '0x8f693ca8D21b157107184d29D398A8D082b38b76',
            },
            137: { // Polygon
                'USDC': '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',
                'USDT': '0xc2132D05D31c914a87C6611C10748AEb04B58e8F',
                'DATA': '0x3a9A81d576d83FF21f26f325066054540720fC34',
            },
            42161: { // Arbitrum One
                'USDC': '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
                'USDT': '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',
            },
            10: { // Optimism
                'USDC': '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',
                'USDT': '0x94b008aA00579c1307B0EF2c499aD98a8ce58e58',
            },
            8453: { // Base
                'USDC': '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
                'USDT': '0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6Ca',
            }
        };
        const TOKEN_DECIMALS = { 'USDC': 6, 'USDT': 6, 'DATA': 18 }; 

        // --- Constants and Mappings ---
        const resolutions = [ { text: '480p', value: '640x480' }, { text: '720p', value: '1280x720' }, { text: '1080p', value: '1920x1080' }];
        const audioQualities = [ 
            { text: 'Voice (32 Kb)', bitrate: 32000 }, 
            { text: 'Balanced (64 Kb)', bitrate: 64000 }, 
            { text: 'High-Fidelity (128 Kb)', bitrate: 128000 },
            { text: 'Studio (256 Kb)', bitrate: 256000 }
        ];

        // --- State Variables ---
        let streamrClient;
        let videoEncoder, audioEncoder, videoDecoder, audioDecoder;
        let localStream, audioContext, gainNode;
        let videoSubscription, audioSubscription, presenceSubscription, chatSubscription, lobbySubscription;
        let isBroadcasting = false, isViewing = false;
        let mySessionId = '';
        let myRealAddress = '';
        let currentChainId = null;
        let myNickname = '';
        let myRoomName = ''; // New state variable for the room name
        let roomNameToJoin = null; // To store room name from URL
        let currentBroadcasterAddress = null; // For tipping
        let userNicknames = new Map();
        let roomNames = new Map(); // Map from partition to room name
        let verifiedUsers = new Map(); // To cache verification results
        let lastKeyFrameTimestamp = 0, lastChunkReceivedTimestamp = 0, streamHealthInterval = null;
        const STALE_STREAM_TIMEOUT_MS = 3000;
        let broadcastSourceType = 'camera';
        let audioMeter = { context: null, stream: null, analyser: null, animationId: null };
        let currentUserId = null;
        let myPartition = null; // My active partition number (1-99)
        const activePartitions = new Map(); // Map from partition number to stream info
        let presenceHeartbeatInterval = null, broadcasterPresenceInterval = null;
        const VIEWER_TIMEOUT_MS = 15000, HEARTBEAT_INTERVAL_MS = 10000;
        let detailedWatchStatus = 'Looking for a broadcast...';
        
        // --- Viewer Playback State ---
        let videoBuffer = [], audioBuffer = [];
        let isPlaying = false, isManuallyPaused = false;
        let playbackStartTime = 0, mediaStartTime = 0;
        let effectiveBufferTargetMs = LIVE_BUFFER_TARGET_MS;
        let nextAudioScheduleTime = 0;
        let lastRenderedFrame = null, currentStreamConfigId = null; 
        let waitingForKeyframe = false; // Flag to force recovery

        const userColors = new Map();
        const userRealAddresses = new Map();
        const colorPalette = [
            '#FF8A65', '#4FC3F7', '#AED581', '#F06292',
            '#BA68C8', '#FFD54F', '#4DB6AC', '#7986CB'
        ];
        
        // --- Dynamic Stream ID Generation ---
        // Generates a stream ID for a specific partition
        function getStreamId(type, partition) {
            let streamBase;
            switch(type) {
                case 'video': streamBase = VIDEO_STREAM_BASE; break;
                case 'audio': streamBase = AUDIO_STREAM_BASE; break;
                case 'presence': streamBase = PRESENCE_STREAM_BASE; break;
                case 'chat': streamBase = CHAT_STREAM_BASE; break;
                default: throw new Error(`Unknown stream type: ${type}`);
            }
            return { streamId: streamBase, partition: partition };
        }
        // Gets the global stream ID for lobby messages
        function getGlobalStreamId(type) {
            if (type === 'lobby') {
                return LOBBY_STREAM_ID;
            }
            // Fallback for other global streams if needed, though lobby is the only one right now
            return `${STREAM_BASE}/${type}`;
        }

        // --- Dynamic Room/Lobby Logic ---
        function updateStreamListUI() {
            streamListContainer.innerHTML = ''; // Clear the list

            // Filter for live streams
            const liveStreams = Array.from(activePartitions.entries())
                .filter(([partition, info]) => {
                    return info && info.broadcaster && (Date.now() - info.lastSeen < VIEWER_TIMEOUT_MS);
                })
                .sort(([pA, infoA], [pB, infoB]) => {
                    // Sort by viewer count, descending
                    return (infoB.viewerCount || 0) - (infoA.viewerCount || 0);
                });

            // Populate the list with sorted, live streams
            liveStreams.forEach(([partition, partitionInfo]) => {
                const streamItem = document.createElement('div');
                streamItem.className = 'stream-item stream-item-live group relative';
                streamItem.onclick = () => joinStream(partition);

                const roomName = roomNames.get(partition) || `Room ${partition}`;
                
                streamItem.innerHTML = `
                   <div class="flex flex-col justify-between h-full">
                        <div>
                            <div class="flex items-center justify-between w-full mb-2">
                                <div class="flex items-center gap-2">
                                    <span class="status-dot dot-green" title="Live"></span>
                                    <span class="font-semibold text-white truncate" title="${sanitizeHTML(roomName)}">${sanitizeHTML(roomName)}</span>
                                </div>
                                <div class="flex items-center gap-1 text-sm text-zinc-400">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                                    <span>${partitionInfo.viewerCount || 0}</span>
                                </div>
                            </div>
                            <p class="text-sm text-zinc-400 text-left">by ${getDisplayName(partitionInfo.broadcaster.publisherId)}</p>
                        </div>
                    </div>
                    <div class="absolute top-0 left-0 right-0 bottom-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-white" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                    </div>
                `;
                streamListContainer.appendChild(streamItem);
            });
            
            lobbyStatus.textContent = liveStreams.length > 0 ? 'Select a room to watch or start your own stream.' : 'No active streams. Be the first to go live!';
        }
        
        async function startLobby() {
            showPage('lobby');
            updateStreamListUI(); // Initial rendering
            
            if (lobbySubscription) { await lobbySubscription.unsubscribe(); }

            let hasAttemptedJoin = false; // Flag to prevent multiple join attempts
            let joinAttemptTimeout = null;

            if (roomNameToJoin) {
                lobbyStatus.textContent = `Searching for room "${roomNameToJoin}"...`;
                joinAttemptTimeout = setTimeout(() => {
                    if (!hasAttemptedJoin) {
                        lobbyStatus.textContent = `Room "${roomNameToJoin}" could not be found or is offline.`;
                        roomNameToJoin = null; // Clear it so we don't keep searching
                        // Reset to default message after a few seconds
                        setTimeout(() => {
                             if(lobbyStatus) updateStreamListUI(); // This will reset the lobby status text based on active streams
                        }, 3000);
                    }
                }, 8000); // 8 second timeout
            }
            
            lobbySubscription = await streamrClient.subscribe(LOBBY_STREAM_ID, (message, metadata) => {
                if (message.type === 'stream_update') {
                    const partition = message.partition;
                    if (message.broadcaster) {
                         const { publisherId, realAddress, nickname, roomName } = message.broadcaster;
                         if (realAddress) { userRealAddresses.set(publisherId, realAddress); }
                         if (nickname) { userNicknames.set(publisherId, nickname); }
                         if (roomName) { roomNames.set(partition, roomName); }
                    } else {
                        roomNames.delete(partition);
                    }
                    activePartitions.set(partition, {
                        broadcaster: message.broadcaster,
                        viewerCount: message.viewerCount,
                        lastSeen: Date.now()
                    });
                    updateStreamListUI();

                     // Auto-join logic
                    if (roomNameToJoin && !hasAttemptedJoin) {
                        for (const [p, rName] of roomNames.entries()) {
                            // Case-insensitive comparison and decode URI component for spaces etc.
                            if (decodeURIComponent(rName).toLowerCase() === decodeURIComponent(roomNameToJoin).toLowerCase()) {
                                const partitionInfo = activePartitions.get(p);
                                const isLive = partitionInfo && partitionInfo.broadcaster && (Date.now() - partitionInfo.lastSeen < VIEWER_TIMEOUT_MS);
                                if (isLive) {
                                    hasAttemptedJoin = true; // Mark as attempted
                                    clearTimeout(joinAttemptTimeout); // Found it, clear timeout
                                    console.log(`Found room "${roomNameToJoin}" in partition ${p}. Attempting to join...`);
                                    joinStream(p);
                                    roomNameToJoin = null; // Clear after joining
                                }
                                break; // Stop searching once found
                            }
                        }
                    }
                } else if (message.type === 'identity_proof') {
                    verifyIdentityProof(message);
                }
            });

            // Periodically check for stale streams
            setInterval(() => {
                let listChanged = false;
                activePartitions.forEach((streamInfo, partition) => {
                    // Remove broadcaster info if heartbeat is too old
                    if (streamInfo.broadcaster && (Date.now() - streamInfo.lastSeen > VIEWER_TIMEOUT_MS)) {
                        activePartitions.set(partition, { ...streamInfo, broadcaster: null, viewerCount: 0});
                        roomNames.delete(partition);
                        listChanged = true;
                    }
                });
                if (listChanged) {
                    updateStreamListUI();
                }
            }, 5000);
        }

        // --- Helper Functions ---
        function showToast(message) {
            if (!toast) return;
            toast.textContent = message;
            toast.classList.remove('translate-y-20', 'opacity-0');
            setTimeout(() => {
                toast.classList.add('translate-y-20', 'opacity-0');
            }, 2000); // Hide after 2 seconds
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(() => showToast('Room link copied to clipboard!'))
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                        showToast('Failed to copy link.');
                    });
            } else {
                // Fallback for insecure contexts or older browsers
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed"; // Avoid scrolling to bottom
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast('Room link copied to clipboard!');
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                    showToast('Failed to copy link.');
                }
                document.body.removeChild(textArea);
            }
        }

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        function getColorKey(publisherId) {
            return userRealAddresses.get(publisherId) || publisherId;
        }

        function getUserColor(publisherId) {
            const colorKey = getColorKey(publisherId);
            if (!userColors.has(colorKey)) {
                const hash = simpleHash(colorKey);
                const color = colorPalette[hash % colorPalette.length];
                userColors.set(colorKey, color);
            }
            return userColors.get(colorKey);
        }

        function getDisplayName(publisherId) {
            const realAddress = userRealAddresses.get(publisherId);
            const nickname = userNicknames.get(publisherId);
            const sanitizedNickname = sanitizeHTML(nickname || '');
            const isVerified = verifiedUsers.get(getColorKey(publisherId));

            if (realAddress) { // Wallet user
                const shortAddress = `${realAddress.slice(0, 6)}...${realAddress.slice(-4)}`;
                const verificationMark = isVerified 
                    ? ` <span class="tooltip-container">
                           <span class="cursor-help">✅</span>
                           <span class="tooltip-text !w-56 !-ml-28 !bottom-6 !text-xs !text-left !font-normal">This user has proven ownership of their wallet address through a cryptographic signature.</span>
                       </span>`
                    : '';
                
                if (sanitizedNickname) {
                    return `${sanitizedNickname} (${shortAddress})${verificationMark}`;
                }
                return `${shortAddress}${verificationMark}`;
            } else { // Guest user
                const shortSessionId = `${publisherId.slice(0, 6)}...${publisherId.slice(-4)}`;
                if (sanitizedNickname) {
                    return `${sanitizedNickname} (${shortSessionId})`;
                }
                return shortSessionId;
            }
        }

        // --- Helper Functions ---
        function sanitizeHTML(str) {
            return DOMPurify.sanitize(str, {ALLOWED_TAGS: ['b', 'i', 'strong', 'em', 'a'], ALLOWED_ATTR: ['href', 'target', 'rel']});
        }
        function arrayBufferToBase64(buffer) {
            let binary = '', bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) { binary += String.fromCharCode(bytes[i]); }
            return window.btoa(binary);
        }
        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64), len = binary_string.length, bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
            return bytes.buffer;
        }
        
        function insertIntoSortedBuffer(buffer, item) {
            let low = 0, high = buffer.length;
            while (low < high) {
                const mid = (low + high) >>> 1;
                if (buffer[mid].timestamp < item.timestamp) low = mid + 1;
                else high = mid;
            }
            buffer.splice(low, 0, item);
        }

        function setLoginModalState(state) {
            if (state === 'loading') {
                loginContent.classList.add('hidden');
                loadingContent.classList.remove('hidden');
            } else { // 'buttons'
                loginContent.classList.remove('hidden');
                loadingContent.classList.add('hidden');
            }
        }

        function handleChainChanged(chainId) {
            console.log("Network changed to:", chainId);
            // Reloading is the simplest way to ensure a clean state
            window.location.reload();
        }
        
        async function cleanupClient() {
            if (streamrClient) {
                console.log("Cleaning up previous Streamr client...");
                await streamrClient.destroy();
                streamrClient = null;
            }
        }

        async function connectWithWallet() {
            const injectedProvider = window.ethereum || window.top?.ethereum;
            if (!injectedProvider) {
                alert("MetaMask not found. Please install the MetaMask extension and refresh the page.");
                return;
            }
            try {
                setLoginModalState('loading');
                loadingInstructions.textContent = 'Please follow the instructions in your wallet.';

                // Initialize with a new, secure, anonymous session first.
                await initializeApp();

                // Listen for network changes
                injectedProvider.on('chainChanged', handleChainChanged);

                const provider = new ethers.providers.Web3Provider(injectedProvider);
                await provider.send("eth_requestAccounts", []);
                const signer = provider.getSigner();
                const network = await provider.getNetwork();
                currentChainId = network.chainId;
                
                myRealAddress = await signer.getAddress();
                
                // Now, create and publish the identity proof to link the wallet to the new session ID.
                const proofMsg = `Verifying ownership: My address ${myRealAddress} will be represented by session ${mySessionId}`;
                const proofSignature = await signer.signMessage(proofMsg);

                await streamrClient.publish(LOBBY_STREAM_ID, {
                    type: 'identity_proof',
                    realAddress: myRealAddress,
                    sessionId: mySessionId,
                    proofMsg: proofMsg,
                    signature: proofSignature
                });

                // Trust our own proof immediately
                verifiedUsers.set(getColorKey(mySessionId), true);
                userRealAddresses.set(mySessionId, myRealAddress);
                updateUIVerification(mySessionId); 

            } catch (err) {
                console.error("Wallet connection failed:", err);
                await cleanupClient();
                myRealAddress = '';
                currentChainId = null;
                let errorMessage = "Wallet connection request was rejected or failed.";
                if (err.code === 'ACTION_REJECTED') {
                    errorMessage = "The signature request was rejected in your wallet.";
                }
                alert(errorMessage);
                setLoginModalState('buttons');
            }
        }

        function alignAndMatchHeight() {
            const chatContainer = document.getElementById('chat-container');
            const chatBox = document.querySelector('#chat-container > div');
            if (!chatBox || chatContainer.classList.contains('hidden')) { return; }

            // Target the specific components for alignment, not the whole page or footer
            const playerHeader = document.getElementById('player-header');
            const playerContainer = document.getElementById('player-container');
            
            // Only proceed if we are on the watch page and the elements exist
            if (document.getElementById('watch-page').classList.contains('active') && playerHeader && playerContainer) {
                const headerRect = playerHeader.getBoundingClientRect();
                const containerRect = playerContainer.getBoundingClientRect();
                const mainContainerRect = document.getElementById('main-container').getBoundingClientRect();

                // The top alignment point is the top of the header
                const paddingTop = headerRect.top - mainContainerRect.top;
                
                // The total height is the sum of the header and the main player container,
                // ignoring the footer. This is the distance from the top of the header
                // to the bottom of the player container.
                const totalHeight = containerRect.bottom - headerRect.top;

                chatContainer.style.paddingTop = `${paddingTop}px`;
                chatBox.style.height = `${totalHeight}px`;
            } else {
                 // Fallback for broadcast page, which has a simpler structure
                const activePlayerBox = document.querySelector('#broadcast-page .bg-zinc-800');
                if (activePlayerBox) {
                    const playerRect = activePlayerBox.getBoundingClientRect();
                    const mainContainerRect = document.getElementById('main-container').getBoundingClientRect();
                    const paddingTop = playerRect.top - mainContainerRect.top;
                    chatContainer.style.paddingTop = `${paddingTop}px`;
                    chatBox.style.height = `${playerRect.height}px`;
                }
            }
        }

        function showPage(pageName) {
            Object.values(pages).forEach(p => p.classList.remove('active'));
            if(pages[pageName]) pages[pageName].classList.add('active');
            
            if (pageName === 'broadcast' || pageName === 'watch') {
                videoColumn.classList.remove('lg:col-span-5');
                videoColumn.classList.add('lg:col-span-3');
                chatContainer.classList.remove('hidden');
                setTimeout(alignAndMatchHeight, 50); // Align after page is shown
            } else {
                videoColumn.classList.remove('lg:col-span-3');
                videoColumn.classList.add('lg:col-span-5');
                chatContainer.classList.add('hidden');
                chatContainer.style.paddingTop = '0px';
                const chatBox = document.querySelector('#chat-container > div');
                if (chatBox) chatBox.style.height = null; 
            }
            if (pageName !== 'settings') stopAudioMeter();
        }

        // --- Audio Meter Logic ---
        function stopAudioMeter() {
            if (audioMeter.animationId) cancelAnimationFrame(audioMeter.animationId);
            audioMeter.stream?.getTracks().forEach(track => track.stop());
            if(audioMeter.context?.state !== 'closed') audioMeter.context?.close();
            const ctx = audioMeterCanvas.getContext('2d');
            ctx.clearRect(0, 0, audioMeterCanvas.width, audioMeterCanvas.height);
            audioMeter = { context: null, stream: null, analyser: null, animationId: null };
        }
        async function startAudioMeter(deviceId) {
            stopAudioMeter(); if (!deviceId) return;
            try {
                audioMeter.stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { deviceId: { exact: deviceId }, autoGainControl: false, echoCancellation: true, noiseSuppression: true } 
                });
                audioMeter.context = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioMeter.context.createMediaStreamSource(audioMeter.stream);
                audioMeter.analyser = audioMeter.context.createAnalyser();
                audioMeter.analyser.fftSize = 256;
                source.connect(audioMeter.analyser);
                const bufferLength = audioMeter.analyser.frequencyBinCount, dataArray = new Uint8Array(bufferLength);
                const canvasCtx = audioMeterCanvas.getContext('2d');
                function draw() {
                    audioMeter.animationId = requestAnimationFrame(draw);
                    audioMeter.analyser.getByteFrequencyData(dataArray);
                    let sum = 0; for(let i=0; i<bufferLength; i++) sum+=dataArray[i];
                    const average = sum/bufferLength, width=(average/128)*audioMeterCanvas.width;
                    canvasCtx.clearRect(0,0,audioMeterCanvas.width,audioMeterCanvas.height);
                    const gradient = canvasCtx.createLinearGradient(0,0,audioMeterCanvas.width,0);
                    gradient.addColorStop(0,'#4ade80'); gradient.addColorStop(0.7,'#facc15'); gradient.addColorStop(1,'#f87171');
                    canvasCtx.fillStyle = gradient; canvasCtx.fillRect(0,0,width,audioMeterCanvas.height);
                }; draw();
            } catch (err) { console.error("Error starting audio meter:", err); }
        }
        
        // --- Settings Page Logic ---
        async function populateDeviceLists() {
            settingsStatus.textContent = '';
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                videoSourceSelect.innerHTML = ''; audioSourceSelect.innerHTML = '';
                let hasVideo = false, hasAudio = false;
                devices.forEach(device => {
                    if (!device.label || !device.deviceId || device.kind === 'audiooutput') return; 
                    const option = document.createElement('option'); option.value = device.deviceId;
                    if (device.kind === 'videoinput') { option.text = device.label || `Camera ${videoSourceSelect.length + 1}`; videoSourceSelect.appendChild(option); hasVideo = true; }
                    else if (device.kind === 'audioinput') { option.text = device.label || `Microphone ${audioSourceSelect.length + 1}`; audioSourceSelect.appendChild(option); hasAudio = true; }
                });
                videoSourceSelect.disabled = !hasVideo; audioSourceSelect.disabled = !hasAudio; audioQualitySlider.disabled = !hasAudio;
                
                if (broadcastSourceType === 'camera') { 
                    startBroadcastBtn.disabled = !hasVideo; 
                } else { 
                    startBroadcastBtn.disabled = false; 
                }
                
                if (hasAudio) { startAudioMeter(audioSourceSelect.value); } else { stopAudioMeter(); }

            } catch (err) { 
                console.error("Error enumerating devices:", err);
                settingsStatus.textContent = `Error getting devices: ${err.message}.`;
            }
        }
        
        // --- Chat & Identity Logic ---
        async function verifyIdentityProof(message) {
            const { realAddress, sessionId, proofMsg, signature } = message;
            if (!realAddress || !sessionId || !proofMsg || !signature) return;

            const colorKey = userRealAddresses.get(sessionId) || sessionId;
            if (verifiedUsers.has(colorKey)) return; 

            try {
                const recoveredAddress = ethers.utils.verifyMessage(proofMsg, signature);
                if (recoveredAddress.toLowerCase() === realAddress.toLowerCase()) {
                    console.log(`Identity verified for ${realAddress} linked to session ${sessionId}`);
                    userRealAddresses.set(sessionId, realAddress);
                    verifiedUsers.set(getColorKey(sessionId), true);
                    updateUIVerification(sessionId);
                }
            } catch (e) {
                console.error("Failed to verify identity proof:", e);
            }
        }

        function updateUIVerification(sessionId) {
            const broadcasterInfo = activePartitions.get(myPartition)?.broadcaster;
            if (broadcasterInfo && broadcasterInfo.publisherId === sessionId) {
                broadcasterDisplayName.innerHTML = `Streaming now: ${getDisplayName(sessionId)}`;
            }

            document.querySelectorAll(`.message-entry[data-publisher-id="${sessionId}"] .chat-username`).forEach(el => {
                el.innerHTML = `${getDisplayName(sessionId)}:`;
            });
            
            if (mySessionId === sessionId) {
                if(chatUserId) chatUserId.innerHTML = getDisplayName(mySessionId);
                if (broadcasterUserId) broadcasterUserId.innerHTML = getDisplayName(mySessionId);
            }
        }


        async function addMessageToUI(message, metadata) {
            if (typeof message !== 'object' || message === null) {
                console.warn("Received non-object message, skipping:", message);
                return;
            }

            if (message.realAddress) { 
                userRealAddresses.set(metadata.publisherId, message.realAddress); 
            }
            if (message.nickname) { 
                userNicknames.set(metadata.publisherId, message.nickname); 
            }

            const msgDiv = document.createElement('div');
            
            if (message.type === 'tip' && message.txHash && message.chainId) {
                msgDiv.className = 'tip-notification opacity-50';
                msgDiv.innerHTML = 'Verifying tip...';
                messagesContainer.appendChild(msgDiv);

                try {
                    const network = NETWORKS[message.chainId];
                    if (!network || !network.rpcUrl) throw new Error('Unsupported network for verification.');

                    const provider = new ethers.providers.JsonRpcProvider(network.rpcUrl);
                    const tx = await provider.getTransaction(message.txHash);
                    
                    const isTxValid = tx &&
                        tx.from.toLowerCase() === message.realAddress.toLowerCase() &&
                        tx.to.toLowerCase() === currentBroadcasterAddress.toLowerCase();

                    if (!isTxValid) throw new Error('Transaction data does not match.');

                    const explorerLink = `${network.explorer}/tx/${message.txHash}`;
                    msgDiv.classList.remove('opacity-50');
                    msgDiv.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-2 align-middle" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.5 2.5 0 00-1.134 0V7.418zM12.25 10a2.5 2.5 0 01-2.25 2.45V15a.75.75 0 01-1.5 0v-2.55a2.5 2.5 0 01-2.25-2.45V9a.75.75 0 011.5 0v1h.75a.75.75 0 010 1.5H9.5v-1a.75.75 0 011.5 0v1h.75a.75.75 0 010 1.5H11v-1a.75.75 0 011.5 0V10z" />
                          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-1.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z" clip-rule="evenodd" />
                        </svg>
                        <span class="align-middle">${sanitizeHTML(message.text)}</span>
                        <a href="${explorerLink}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline ml-2">(view tx)</a>
                    `;
                } catch (err) {
                    console.error("Tip verification failed:", err);
                    msgDiv.innerHTML = 'Tip verification failed.';
                    setTimeout(() => msgDiv.remove(), 3000);
                }

            } else {
                msgDiv.className = 'message-entry text-sm';
                msgDiv.setAttribute('data-publisher-id', metadata.publisherId);

                const userSpan = document.createElement('span');
                userSpan.className = 'chat-username';
                userSpan.innerHTML = `${getDisplayName(metadata.publisherId)}:`;
                userSpan.style.color = getUserColor(metadata.publisherId);

                const textSpan = document.createElement('span');
                textSpan.className = 'chat-message-text';
                textSpan.innerHTML = sanitizeHTML(message.text);

                msgDiv.appendChild(userSpan);
                msgDiv.appendChild(textSpan);
                messagesContainer.appendChild(msgDiv);
            }
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            if(messagesContainer.children.length > MAX_MESSAGES){ 
                messagesContainer.removeChild(messagesContainer.firstChild);
            }
        }


        async function sendMessage() {
            const text = messageInput.value.trim();
            if(!text || !streamrClient) return;
            try {
                const payload = { 
                    text: text,
                    realAddress: myRealAddress,
                    nickname: myNickname,
                };
                await streamrClient.publish(getStreamId('chat', myPartition), payload);
                messageInput.value = ''; messageInput.focus();
            } catch(error){
                console.error("Failed to send message:", error);
                alert('Failed to send: ' + error.message);
            }
        }
        async function startChat() {
            if (chatSubscription) return;
            try {
                chatSubscription = await streamrClient.subscribe(getStreamId('chat', myPartition), (message, metadata) => addMessageToUI(message, metadata));
            } catch(error){
                console.error("Error starting chat:", error);
            }
        }
        async function stopChat() {
            if (chatSubscription) { await chatSubscription.unsubscribe(); chatSubscription = null; }
        }

        // --- Core Logic ---
        async function initializeApp() {
            await cleanupClient();
            try {
                if(!loginModal.classList.contains('hidden')) {
                    setLoginModalState('loading');
                    loadingInstructions.textContent = 'Connecting to the P2P network...';
                }
                
                streamrClient = new StreamrClient(); // Secure anonymous session
                await streamrClient.connect();
                mySessionId = await streamrClient.getAddress();
                
                const nicknameKey = myRealAddress || mySessionId;
                myNickname = sessionStorage.getItem(`nickname_${nicknameKey}`) || '';
                if(myNickname) {
                    userNicknames.set(mySessionId, myNickname);
                }
                
                if(chatUserId) chatUserId.innerHTML = getDisplayName(mySessionId);
                if (broadcasterUserId) broadcasterUserId.innerHTML = getDisplayName(mySessionId);

                loginModal.classList.add('hidden');
                startLobby();
            } catch (error) {
                console.error('Failed to initialize Streamr client:', error);
                alert(`Error connecting: ${error.message}. Please refresh.`);
                setLoginModalState('buttons');
            }
        }

        function setupEventListeners() {
            // Login
            guestBtn.onclick = () => {
                initializeApp();
            };
            connectWalletBtn.onclick = () => {
                connectWithWallet();
            };

            // Nickname
            if (nicknameBtn) {
                nicknameBtn.onclick = () => {
                    nicknameInput.value = myNickname;
                    nicknameModal.classList.remove('hidden');
                };
            }
            if (nicknameBtnBroadcast) {
                nicknameBtnBroadcast.onclick = () => {
                    nicknameInput.value = myNickname;
                    nicknameModal.classList.remove('hidden');
                };
            }
            saveNicknameBtn.onclick = () => {
                const newNickname = sanitizeHTML(nicknameInput.value.trim());
                myNickname = newNickname;
                const nicknameKey = myRealAddress || mySessionId;
                sessionStorage.setItem(`nickname_${nicknameKey}`, myNickname);
                userNicknames.set(mySessionId, myNickname);
                if(chatUserId) chatUserId.innerHTML = getDisplayName(mySessionId);
                if (broadcasterUserId) broadcasterUserId.innerHTML = getDisplayName(mySessionId);
                nicknameModal.classList.add('hidden');
            };
            resetNicknameBtn.onclick = () => {
                myNickname = '';
                const nicknameKey = myRealAddress || mySessionId;
                sessionStorage.removeItem(`nickname_${nicknameKey}`);
                userNicknames.delete(mySessionId);
                if(chatUserId) chatUserId.innerHTML = getDisplayName(mySessionId);
                if (broadcasterUserId) broadcasterUserId.innerHTML = getDisplayName(mySessionId);
                nicknameModal.classList.add('hidden');
            };
            if (nicknameModal) nicknameModal.onclick = (e) => {
                if (e.target === nicknameModal) { nicknameModal.classList.add('hidden'); }
            };

            // Navigation
            startBroadcastBtn.onclick = startBroadcast;
            const backToLobbyBtns = document.querySelectorAll('#back-to-lobby-btn, #back-to-lobby-btn-settings');
            backToLobbyBtns.forEach(btn => btn.onclick = goBackToLobby);

            if (goLiveBtnLobby) {
                goLiveBtnLobby.onclick = () => {
                    myPartition = null; // Ensure partition is null to trigger auto-find
                    initiateBroadcastFlow();
                };
            }

            // Watch Page Controls
            if (fullscreenBtn) fullscreenBtn.onclick = () => { if (document.fullscreenElement) document.exitFullscreen(); else canvasWrapper.requestFullscreen().catch(err => showToast(`Fullscreen Error: ${err.message}`)); };
            if (playPauseBtn) playPauseBtn.onclick = () => {
                isManuallyPaused = !isManuallyPaused;
                if(playIcon) playIcon.classList.toggle('hidden', !isManuallyPaused);
                if(pauseIcon) pauseIcon.classList.toggle('hidden', isManuallyPaused);
                if (audioContext) {
                    if (isManuallyPaused) {
                        audioContext.suspend();
                    } else {
                        // When unpausing, reset the start times to smoothly resume
                        playbackStartTime = audioContext.currentTime;
                        mediaStartTime = nextAudioScheduleTime > 0 ? (mediaStartTime + (nextAudioScheduleTime - playbackStartTime) * 1000000) : mediaStartTime;
                        audioContext.resume();
                    }
                }
            };
            if (volumeSlider) volumeSlider.addEventListener('input', e => { if (gainNode) gainNode.gain.setValueAtTime(e.target.value / 100, audioContext.currentTime); });
            
            if (bufferSlider) bufferSlider.addEventListener('input', e => {
                const newBufferValue = parseInt(e.target.value, 10);
                effectiveBufferTargetMs = newBufferValue;
                
                let label = '';
                if (newBufferValue <= 200) {
                    label = '(Lowest Latency)';
                } else if (newBufferValue >= 2500) {
                    label = '(Maximum Stability)';
                }
                bufferValue.textContent = `${newBufferValue} ms ${label}`.trim();
            });
            if (toggleLatencyControlsBtn) {
                toggleLatencyControlsBtn.onclick = () => {
                    latencyControlsCollapsible.classList.toggle('hidden');
                    toggleLatencyArrow.classList.toggle('open');
                    setTimeout(alignAndMatchHeight, 50); 
                };
            }

            // Share buttons
            if(shareBtnBroadcast) shareBtnBroadcast.onclick = () => {
                const roomUrl = `${window.location.origin}/${encodeURIComponent(myRoomName)}`;
                copyToClipboard(roomUrl);
            };
            if(shareBtnWatch) shareBtnWatch.onclick = () => {
                const roomName = roomNames.get(myPartition) || '';
                if (roomName) {
                    const roomUrl = `${window.location.origin}/${encodeURIComponent(roomName)}`;
                    copyToClipboard(roomUrl);
                }
            };


            // Settings Page Controls
            if (audioSourceSelect) audioSourceSelect.addEventListener('change', () => startAudioMeter(audioSourceSelect.value));
            if (resolutionSlider) resolutionSlider.addEventListener('input', e => { resolutionValue.textContent = resolutions[e.target.value].text; });
            if (bitrateSlider) bitrateSlider.addEventListener('input', e => { bitrateValue.textContent = `${(e.target.value / 1000000).toFixed(1)} Mbps`; });
            if (framerateSlider) framerateSlider.addEventListener('input', e => { framerateValue.textContent = `${e.target.value} fps`; });
            if (audioQualitySlider) audioQualitySlider.addEventListener('input', e => { audioQualityValue.textContent = audioQualities[e.target.value].text; });
            const performanceModes = ['Lowest Latency', 'Best Quality'];
            if (performanceSlider) performanceSlider.addEventListener('input', e => { performanceValue.textContent = performanceModes[e.target.value]; });
            if (keyframeIntervalSlider) keyframeIntervalSlider.addEventListener('input', e => { keyframeIntervalValue.textContent = `${(e.target.value / 1000).toFixed(1)} s`; });
            if (broadcastSourceRadios) broadcastSourceRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    broadcastSourceType = e.target.value;
                    document.querySelectorAll('label[for^="source-"]').forEach(label => { label.classList.remove('bg-zinc-600', 'text-white'); label.classList.add('hover:bg-zinc-600/50'); });
                    const selectedLabel = document.querySelector(`label[for="${e.target.id}"]`); selectedLabel.classList.add('bg-zinc-600', 'text-white'); selectedLabel.classList.remove('hover:bg-zinc-600/50');
                    const isCamera = broadcastSourceType === 'camera';
                    if (inputDevicesGroup) inputDevicesGroup.style.display = isCamera ? 'block' : 'none';
                    if (videoQualityGroup) videoQualityGroup.style.display = 'block'; // Always show video quality group
                    if (resolutionSetting) resolutionSetting.style.display = isCamera ? 'block' : 'none';
                    if (framerateSetting) framerateSetting.style.display = isCamera ? 'block' : 'none';
                    if (isCamera) { 
                        populateDeviceLists(); 
                    } else { 
                        if (startBroadcastBtn) startBroadcastBtn.disabled = false; 
                        stopAudioMeter(); 
                    }
                });
            });
            
            // Chat Controls
            if (sendBtn) sendBtn.addEventListener('click', sendMessage);
            if (messageInput) messageInput.addEventListener('keypress', (e) => { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendMessage(); } });
            if (emojiBtn) emojiBtn.addEventListener('click', (e) => { e.stopPropagation(); if (emojiPicker) emojiPicker.style.display = emojiPicker.style.display === 'flex' ? 'none' : 'flex'; });
            emojis.forEach(e => {
                const span = document.createElement('span'); span.textContent = e;
                span.addEventListener('click', () => { if(messageInput) messageInput.value += e; if(messageInput) messageInput.focus(); if(emojiPicker) emojiPicker.style.display = 'none'; });
                if (emojiPicker) emojiPicker.appendChild(span);
            });

            // Tipping Modal Listeners
            if (tipBtn) {
                tipBtn.onclick = () => {
                    updateTipModalUI(); // Populate tokens based on current network
                    if (tipModal) tipModal.classList.remove('hidden');
                    if (tipInitialView) tipInitialView.style.display = 'block';
                    if (tipLoadingView) tipLoadingView.style.display = 'none';
                    if (tipSuccessView) tipSuccessView.style.display = 'none';
                    if (tipAmountInput) tipAmountInput.value = '';
                    if (tipErrorMsg) tipErrorMsg.textContent = '';
                };
            }
            if (cancelTipBtn) cancelTipBtn.onclick = () => tipModal.classList.add('hidden');
            if (closeTipSuccessBtn) closeTipSuccessBtn.onclick = () => tipModal.classList.add('hidden');
            if (sendTipBtn) sendTipBtn.onclick = sendTip;
            if (tipModal) tipModal.onclick = (e) => { if (e.target === tipModal) tipModal.classList.add('hidden'); };
            if (tipTokenSelect) tipTokenSelect.onchange = () => {
                const selectedToken = tipTokenSelect.value;
                const network = NETWORKS[currentChainId] || { symbol: 'Coin' };
                const symbol = selectedToken === 'native' ? network.symbol : selectedToken;
                tipAmountLabel.textContent = `Amount (${symbol})`;
            };
            
            // Global Listeners
            document.addEventListener('click', (e) => { if (emojiPicker && !emojiPicker.contains(e.target) && e.target !== emojiBtn) { emojiPicker.style.display = 'none'; } });
            window.addEventListener('resize', alignAndMatchHeight);
            window.addEventListener('beforeunload', () => { if(isViewing && currentUserId) streamrClient.publish(getStreamId('presence', myPartition), { type:'leave', userId:currentUserId }); });
        }
        
        async function initiateBroadcastFlow() {
            if(lobbyStatus) lobbyStatus.textContent = 'Requesting permissions...';
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                tempStream.getTracks().forEach(track => track.stop()); // Stop immediately
                showPage('settings');
                if (roomNameInput) roomNameInput.value = ''; // Clear input on page load

                // Explicitly reset the radio button state to ensure the 'change' event fires correctly.
                const cameraRadio = document.getElementById('source-camera');
                if (cameraRadio) {
                    cameraRadio.checked = true;
                    // Trigger the change event to set the initial state to 'camera' and populate device lists.
                    cameraRadio.dispatchEvent(new Event('change'));
                }

            } catch (err) {
                console.error("Permission error on initial request:", err);
                if (err.name === 'NotAllowedError') {
                    if(lobbyStatus) lobbyStatus.textContent = 'Permission denied. Please allow access in browser settings.';
                } else {
                    if(lobbyStatus) lobbyStatus.textContent = `An error occurred: ${err.name}.`;
                }
                setTimeout(() => { if(lobbyStatus) updateStreamListUI(); }, 3000);
            }
        }

        function main() {
            // --- Parse URL for deep links ---
            const path = window.location.pathname;
            if (path && path !== '/') {
                // Remove leading slash and decode
                roomNameToJoin = decodeURIComponent(path.substring(1));
                console.log(`Attempting to join room from URL: "${roomNameToJoin}"`);
            }

            // --- Initialize UI Elements ---
            mainContainer = document.getElementById('main-container');
            videoColumn = document.getElementById('video-column');
            pages = { lobby: document.getElementById('lobby-page'), settings: document.getElementById('settings-page'), broadcast: document.getElementById('broadcast-page'), watch: document.getElementById('watch-page') };
            startBroadcastBtn = document.getElementById('start-broadcast-btn');
            localVideo = document.getElementById('localVideo');
            remoteCanvas = document.getElementById('remoteCanvas');
            canvasWrapper = document.getElementById('canvas-wrapper');
            broadcastStatus = document.getElementById('broadcast-status');
            watchStatus = document.getElementById('watch-status');
            statusDot = document.getElementById('statusDot');
            fullscreenBtn = document.getElementById('fullscreen-btn');
            playPauseBtn = document.getElementById('playPauseBtn');
            playIcon = document.getElementById('playIcon');
            pauseIcon = document.getElementById('pauseIcon');
            viewerCountBroadcaster = document.getElementById('viewer-count-broadcaster');
            viewerCountBroadcasterValue = document.getElementById('viewer-count-broadcaster-value');
            viewerCountWatcher = document.getElementById('viewer-count-watcher');
            viewerCountWatcherValue = document.getElementById('viewer-count-watcher-value');
            broadcastSourceRadios = document.querySelectorAll('input[name="broadcast-source"]');
            inputDevicesGroup = document.getElementById('input-devices-group');
            videoQualityGroup = document.getElementById('video-quality-group');
            videoSourceSelect = document.getElementById('videoSourceSelect');
            audioSourceSelect = document.getElementById('audioSourceSelect');
            audioMeterCanvas = document.getElementById('audio-meter-canvas');
            resolutionSlider = document.getElementById('resolutionSlider');
            resolutionValue = document.getElementById('resolutionValue');
            resolutionSetting = document.getElementById('resolution-setting');
            framerateSetting = document.getElementById('framerate-setting');
            bitrateSlider = document.getElementById('bitrateSlider');
            bitrateValue = document.getElementById('bitrateValue');
            framerateSlider = document.getElementById('framerateSlider');
            framerateValue = document.getElementById('framerateValue');
            audioQualitySlider = document.getElementById('audioQualitySlider');
            audioQualityValue = document.getElementById('audioQualityValue');
            performanceSlider = document.getElementById('performanceSlider');
            performanceValue = document.getElementById('performanceValue');
            keyframeIntervalSlider = document.getElementById('keyframeIntervalSlider');
            keyframeIntervalValue = document.getElementById('keyframeIntervalValue');
            volumeSlider = document.getElementById('volume-slider');
            bufferSlider = document.getElementById('bufferSlider');
            bufferValue = document.getElementById('bufferValue');
            latencyControls = document.getElementById('latency-controls');
            canvasContext = remoteCanvas.getContext('2d');
            loginModal = document.getElementById('loginModal');
            loginContent = document.getElementById('loginContent');
            loadingContent = document.getElementById('loadingContent');
            connectWalletBtn = document.getElementById('connectWalletBtn');
            guestBtn = document.getElementById('guestBtn');
            loadingInstructions = document.getElementById('loading-instructions');
            chatContainer = document.getElementById('chat-container');
            messageInput = document.getElementById('messageInput');
            sendBtn = document.getElementById('sendBtn');
            emojiBtn = document.getElementById('emojiBtn');
            messagesContainer = document.getElementById('messagesContainer');
            emojiPicker = document.getElementById('emojiPicker');
            nicknameModal = document.getElementById('nicknameModal');
            nicknameInput = document.getElementById('nicknameInput');
            saveNicknameBtn = document.getElementById('saveNicknameBtn');
            resetNicknameBtn = document.getElementById('resetNicknameBtn');
            nicknameBtn = document.getElementById('nicknameBtn');
            chatUserId = document.getElementById('chat-user-id');
            settingsStatus = document.getElementById('settings-status');
            broadcasterUserId = document.getElementById('broadcaster-user-id');
            nicknameBtnBroadcast = document.getElementById('nicknameBtnBroadcast');
            broadcasterInfoOnWatchPage = document.getElementById('broadcaster-info-on-watch-page');
            toggleLatencyControlsBtn = document.getElementById('toggle-latency-controls-btn');
            latencyControlsCollapsible = document.getElementById('latency-controls-collapsible');
            toggleLatencyArrow = document.getElementById('toggle-latency-arrow');
            lobbyPage = document.getElementById('lobby-page');
            streamListContainer = document.getElementById('stream-list-container');
            lobbyStatus = document.getElementById('lobby-status');
            roomNameInput = document.getElementById('roomNameInput'); 
            roomNameOnWatchPage = document.getElementById('roomNameOnWatchPage');
            roomNameOnBroadcastPage = document.getElementById('roomNameOnBroadcastPage');
            shareBtnBroadcast = document.getElementById('shareBtnBroadcast');
            shareBtnWatch = document.getElementById('shareBtnWatch');
            toast = document.getElementById('toast');
            goLiveBtnLobby = document.getElementById('go-live-btn-lobby');
            
            // --- Tipping UI ---
            broadcasterDisplayName = document.getElementById('broadcaster-display-name');
            tipBtn = document.getElementById('tipBtn');
            tipModal = document.getElementById('tipModal');
            tipInitialView = document.getElementById('tip-initial-view');
            tipLoadingView = document.getElementById('tip-loading-view');
            tipSuccessView = document.getElementById('tip-success-view');
            tipRecipientName = document.getElementById('tip-recipient-name');
            tipAmountInput = document.getElementById('tipAmountInput');
            tipErrorMsg = document.getElementById('tip-error-msg');
            cancelTipBtn = document.getElementById('cancelTipBtn');
            sendTipBtn = document.getElementById('sendTipBtn');
            closeTipSuccessBtn = document.getElementById('closeTipSuccessBtn');
            tipEtherscanLink = document.getElementById('tip-etherscan-link');
            tipTokenSelect = document.getElementById('tipTokenSelect');
            tipAmountLabel = document.getElementById('tipAmountLabel');


            // --- Setup Event Listeners ---
            setupEventListeners();
        }

        document.addEventListener('DOMContentLoaded', main);

        // --- Broadcaster ---
        async function startBroadcast() {
            stopAudioMeter();
            settingsStatus.textContent = '';
            
            // Auto-find an available partition if one isn't already selected
            if (myPartition === null) {
                let foundPartition = false;
                for (let i = 1; i <= PARTITIONS; i++) {
                    const partitionInfo = activePartitions.get(i);
                    const isLive = partitionInfo && partitionInfo.broadcaster && (Date.now() - partitionInfo.lastSeen < VIEWER_TIMEOUT_MS);
                    if (!isLive) {
                        myPartition = i;
                        foundPartition = true;
                        break;
                    }
                }
                if (!foundPartition) {
                    settingsStatus.textContent = 'Sorry, all rooms are currently full. Please try again later.';
                    return;
                }
            }

            const roomName = sanitizeHTML(roomNameInput.value.trim());
            if (roomName.length === 0) {
                settingsStatus.textContent = 'Please enter a name for your room.';
                return;
            }
            myRoomName = roomName; // Save the name to state

            if (!window.VideoEncoder || !window.AudioEncoder) {
                settingsStatus.textContent = 'Error: WebCodecs API not supported in this browser.';
                return;
            }
            try {
                const audioConstraints = { autoGainControl: false, echoCancellation: true, noiseSuppression: true };
                if (broadcastSourceType === 'camera') {
                    const res = resolutions[resolutionSlider.value].value; const [w,h] = res.split('x').map(Number); const fps = parseInt(framerateSlider.value, 10);
                    const constraints = { video: { deviceId:{exact:videoSourceSelect.value}, width:w, height:h, frameRate:{ideal:fps, max:fps} }, audio: { deviceId:{exact:audioSourceSelect.value}, ...audioConstraints } };
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    localVideo.classList.add('camera-view');
                } else {
                    localStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor:"always" }, audio: audioConstraints });
                    localVideo.classList.remove('camera-view'); localStream.getVideoTracks()[0].onended = goBackToLobby;
                }
                const hasVideo = localStream.getVideoTracks().length > 0, hasAudio = localStream.getAudioTracks().length > 0;
                if(!hasVideo && !hasAudio) {
                     settingsStatus.textContent = "Selected source has no video or audio.";
                     localStream.getTracks().forEach(t => t.stop());
                     return;
                }
                showPage('broadcast'); isBroadcasting = true; startBroadcasterPresence(); await startChat(); localVideo.srcObject = localStream;
                let vSettings, statusText = `Broadcasting ${broadcastSourceType} `;
                if(hasVideo) {
                    const trackSettings = localStream.getVideoTracks()[0].getSettings(); const bitrate = parseInt(bitrateSlider.value, 10); const perf = (performanceSlider.value === '0') ? 'realtime' : 'quality';
                    const fps = parseInt(framerateSlider.value, 10); // Get the desired FPS from the slider
                    vSettings = { width:trackSettings.width, height:trackSettings.height, framerate:fps, bitrate }; // Use the desired FPS
                    const vConfig = { codec:'avc1.64002A', width:vSettings.width, height:vSettings.height, bitrate:vSettings.bitrate, framerate:vSettings.framerate, hardwareAcceleration:'prefer-hardware', latencyMode:perf };
                    if (!(await VideoEncoder.isConfigSupported(vConfig)).supported) {
                        goBackToLobby();
                        showToast(`Video settings not supported.`);
                        return;
                    }
                    videoEncoder = new VideoEncoder({ output:(c,m) => handleVideoEncoderOutput(c,m,vSettings), error:e => console.error(`VErr: ${e.message}`) });
                    await videoEncoder.configure(vConfig); readVideoFrames(new MediaStreamTrackProcessor({track:localStream.getVideoTracks()[0]}).readable.getReader());
                    statusText += `(${vSettings.width}x${vSettings.height}@${Math.round(vSettings.framerate)}fps, ${(vSettings.bitrate/1000000).toFixed(1)} Mbps)`;
                }
                if(hasAudio) {
                    const aBitrate = audioQualities[audioQualitySlider.value].bitrate; const aQualityTxt = audioQualities[audioQualitySlider.value].text;
                    const aConfig = { codec:'opus', sampleRate:48000, numberOfChannels:1, bitrate:aBitrate };
                    audioEncoder = new AudioEncoder({ output:handleAudioEncoderOutput, error:e => console.error(`AErr: ${e.message}`) });
                    await audioEncoder.configure(aConfig); readAudioFrames(new MediaStreamTrackProcessor({track:localStream.getAudioTracks()[0]}).readable.getReader());
                    if(hasVideo) statusText += " & "; statusText += `Audio (${aQualityTxt})`;
                }
                broadcastStatus.textContent = statusText;
                if(roomNameOnBroadcastPage) roomNameOnBroadcastPage.textContent = `Room: "${myRoomName}"`;
            } catch (err) {
                console.error(`Broadcast start error: ${err.message}`, err);
                settingsStatus.textContent = `An unexpected error occurred: ${err.name}. Please try again.`;
                showPage('settings');
            }
        }
        async function handleVideoEncoderOutput(chunk, metadata, streamSettings) {
            if (!isBroadcasting) return; const data = new Uint8Array(chunk.byteLength); chunk.copyTo(data);
            const msg = { type:chunk.type, timestamp:chunk.timestamp, duration:chunk.duration, data_base64:arrayBufferToBase64(data.buffer) };
            if (chunk.type === 'key' && metadata.decoderConfig) {
                const config = {...metadata.decoderConfig}; if (config.description) config.description = Array.from(new Uint8Array(config.description));
                config.streamSettings = streamSettings; msg.config = config;
            }
            await streamrClient.publish(getStreamId('video', myPartition), msg);
        }
        async function handleAudioEncoderOutput(chunk) {
            if (!isBroadcasting) return; const data = new Uint8Array(chunk.byteLength); chunk.copyTo(data);
            const msg = { timestamp:chunk.timestamp, duration:chunk.duration, data_base64:arrayBufferToBase64(data.buffer) };
            await streamrClient.publish(getStreamId('audio', myPartition), msg);
        }
        async function readVideoFrames(reader) {
            const interval = parseInt(keyframeIntervalSlider.value, 10);
            while (isBroadcasting) {
                const { value: frame, done } = await reader.read().catch(() => ({done:true})); if (done || !isBroadcasting) break;
                const keyFrame = (Date.now() - lastKeyFrameTimestamp) > interval; if(keyFrame) lastKeyFrameTimestamp = Date.now();
                if(videoEncoder?.state === 'configured') videoEncoder.encode(frame, {keyFrame}); frame.close();
            }
        }
        async function readAudioFrames(reader) {
            while (isBroadcasting) {
                const { value: frame, done } = await reader.read().catch(() => ({done:true})); if (done || !isBroadcasting) break;
                if(audioEncoder?.state === 'configured') audioEncoder.encode(frame); frame.close();
            }
        }
        async function stopBroadcast() {
            isBroadcasting = false; stopBroadcasterPresence();
            localStream?.getTracks().forEach(t => t.stop());
            if (videoEncoder?.state !== 'closed') videoEncoder.close(); if (audioEncoder?.state !== 'closed') audioEncoder.close();
            localVideo.srcObject = null;
        }

        // --- Viewer ---
        function checkStreamHealth() {
            if (isViewing && lastChunkReceivedTimestamp > 0 && (Date.now() - lastChunkReceivedTimestamp > STALE_STREAM_TIMEOUT_MS)) {
                if (!statusDot.classList.contains('dot-yellow-flashing')) { statusDot.className = 'status-dot dot-yellow-flashing'; statusDot.title = 'Unstable connection'; watchStatus.textContent = 'Buffering...'; isPlaying = false; }
            }
        }
        
        const renderAndSchedule = () => {
            if (!isViewing) return;

            if (!isManuallyPaused) {
                // 1. Check if we need to START playback
                if (!isPlaying) {
                    const videoDuration = (videoBuffer.length > 1) ? (videoBuffer[videoBuffer.length-1].timestamp - videoBuffer[0].timestamp) / 1000 : 0;
                    const audioDuration = (audioBuffer.length > 1) ? (audioBuffer[audioBuffer.length-1].timestamp - audioBuffer[0].timestamp) / 1000 : 0;
                    
                    if (videoDuration >= effectiveBufferTargetMs && audioDuration >= effectiveBufferTargetMs) {
                        // We have enough data, let's start!
                        mediaStartTime = audioBuffer[0].timestamp;
                        // Discard any video frames that are older than the first audio frame
                        while (videoBuffer.length > 0 && videoBuffer[0].timestamp < mediaStartTime) {
                            videoBuffer.shift().close();
                        }
                        if (videoBuffer.length > 0) {
                            isPlaying = true;
                            playbackStartTime = audioContext.currentTime;
                            nextAudioScheduleTime = playbackStartTime;
                            watchStatus.textContent = detailedWatchStatus;
                            statusDot.className = 'status-dot dot-green';
                        }
                    }
                }

                // 2. If we are playing, schedule audio and render video
                if (isPlaying) {
                    // Schedule all available audio chunks
                    while (audioBuffer.length > 0) {
                        const audioData = audioBuffer.shift();
                        try {
                            const buffer = audioContext.createBuffer(audioData.numberOfChannels, audioData.numberOfFrames, audioData.sampleRate);
                            for (let i = 0; i < audioData.numberOfChannels; i++) {
                                const chanData = new Float32Array(audioData.numberOfFrames);
                                audioData.copyTo(chanData, { planeIndex: i });
                                buffer.copyToChannel(chanData, i);
                            }
                            const source = audioContext.createBufferSource();
                            source.buffer = buffer;
                            source.connect(gainNode);
                            source.start(nextAudioScheduleTime);
                            nextAudioScheduleTime += buffer.duration;
                        } catch (err) { console.error("Error scheduling audio:", err); } 
                        finally { audioData.close(); }
                    }

                    // Determine the current media time based on the audio clock
                    const mediaTimeUs = mediaStartTime + ((audioContext.currentTime - playbackStartTime) * 1000000);

                    // Find the latest video frame that should be displayed
                    let frameToRender = null;
                    while (videoBuffer.length > 0 && videoBuffer[0].timestamp <= mediaTimeUs) {
                        if (frameToRender) frameToRender.close(); // Discard older frames
                        frameToRender = videoBuffer.shift();
                    }

                    if (frameToRender) {
                        canvasContext.drawImage(frameToRender, 0, 0, remoteCanvas.width, remoteCanvas.height);
                        lastRenderedFrame?.close();
                        lastRenderedFrame = frameToRender;
                    } else if (lastRenderedFrame) {
                        // Redraw the last frame if no new one is ready
                        canvasContext.drawImage(lastRenderedFrame, 0, 0, remoteCanvas.width, remoteCanvas.height);
                    }
                    
                    // 3. Check for buffer underrun
                    if (audioContext.currentTime >= nextAudioScheduleTime && audioBuffer.length === 0) {
                        // We've run out of scheduled audio. We need to pause and wait for the buffer to fill up again.
                        isPlaying = false; 
                        watchStatus.textContent = "Buffering...";
                        statusDot.className = 'status-dot dot-yellow-flashing';
                    }
                }
            }
            requestAnimationFrame(renderAndSchedule);
        };

        async function joinStream(partition) {
            if (!window.VideoDecoder || !window.AudioDecoder) return alert('Error: WebCodecs API not supported.');
            myPartition = partition;
            messagesContainer.innerHTML = '';
            showPage('watch'); isViewing = true; startViewerPresence(); await startChat();
            
            effectiveBufferTargetMs = parseInt(bufferSlider.value, 10);
            
            watchStatus.textContent = detailedWatchStatus; statusDot.className = 'status-dot dot-yellow'; statusDot.title = 'Connecting...';
            streamHealthInterval = setInterval(checkStreamHealth, 1000);
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)(); 
            await audioContext.resume();
            
            gainNode = audioContext.createGain(); 
            gainNode.gain.setValueAtTime(volumeSlider.value / 100, audioContext.currentTime); 
            gainNode.connect(audioContext.destination);

            videoDecoder = new VideoDecoder({
                output: f => {
                    // If we were waiting for a keyframe, we've got one. Resume normal operation.
                    if (waitingForKeyframe) waitingForKeyframe = false;
                    insertIntoSortedBuffer(videoBuffer, f);
                },
                error: e => {
                    console.error(`VDecErr: ${e.message}`);
                    // When a decoding error occurs, we must reset everything to resynchronize.
                    isPlaying = false;
                    videoBuffer.forEach(frame => frame.close());
                    audioBuffer.forEach(chunk => chunk.close());
                    videoBuffer = [];
                    audioBuffer = [];
                    lastRenderedFrame?.close();
                    lastRenderedFrame = null;
                    
                    watchStatus.textContent = "Recovering from stream error...";
                    statusDot.className = 'status-dot dot-yellow-flashing';

                    waitingForKeyframe = true;
                    if (videoDecoder.state === 'configured') {
                        videoDecoder.reset();
                    }
                }
            });

            audioDecoder = new AudioDecoder({
                output: d => insertIntoSortedBuffer(audioBuffer, d),
                error: e => {
                    console.error(`ADecErr: ${e.message}`);
                     // Also reset on audio errors for robustness
                    if (audioDecoder.state === 'configured') {
                        audioDecoder.reset();
                    }
                }
            });

            // Start the unified rendering loop
            renderAndSchedule();

            const handleMessage = () => {
                lastChunkReceivedTimestamp = Date.now();
                if (statusDot.classList.contains('dot-yellow-flashing') || statusDot.classList.contains('dot-yellow')) { 
                    statusDot.className = 'status-dot dot-green'; 
                    statusDot.title = 'Connected'; 
                    if(!isPlaying) watchStatus.textContent = "Buffering...";
                }
            };
            videoSubscription = await streamrClient.subscribe(getStreamId('video', myPartition), msg => {
                if (!isViewing) return; handleMessage();
                if (msg.config) {
                    const newConfig = msg.config, newConfigId = `${newConfig.codedWidth}x${newConfig.codedHeight}`;
                    const s = newConfig.streamSettings;
                    detailedWatchStatus = s ? `Receiving: ${s.width}x${s.height} @ ${Math.round(s.framerate)}fps, ~${(s.bitrate / 1000000).toFixed(1)}Mbps` : `Receiving: ${newConfig.codedWidth}x${newConfig.codedHeight}`; 
                    watchStatus.textContent = detailedWatchStatus;
                    if (newConfigId !== currentStreamConfigId) {
                        currentStreamConfigId = newConfigId; if (newConfig.description) newConfig.description = new Uint8Array(newConfig.description).buffer;
                        videoDecoder.configure(newConfig); 
                        videoBuffer.forEach(f=>f.close()); audioBuffer.forEach(c=>c.close()); lastRenderedFrame?.close(); videoBuffer=[]; audioBuffer=[]; lastRenderedFrame=null; isPlaying=false; waitingForKeyframe = false; // Reset recovery flag on new config
                        if(audioDecoder.state === 'configured') audioDecoder.reset(); if(audioContext) nextAudioScheduleTime = audioContext.currentTime;
                        remoteCanvas.width = newConfig.codedWidth; remoteCanvas.height = newConfig.codedHeight; canvasWrapper.style.aspectRatio = `${newConfig.codedWidth} / ${newConfig.codedHeight}`;
                    }
                }
                // If we are in recovery mode, only decode keyframes
                if (waitingForKeyframe && msg.type !== 'key') {
                    console.log("Skipping delta frame while waiting for keyframe.");
                    return;
                }
                if (videoDecoder.state === 'configured') { try { videoDecoder.decode(new EncodedVideoChunk({ type:msg.type, timestamp:msg.timestamp, duration:msg.duration, data:base64ToArrayBuffer(msg.data_base64) })); } catch (e) { console.error("Error decoding video chunk:", e); } }
            });
            audioSubscription = await streamrClient.subscribe(getStreamId('audio', myPartition), msg => {
                if (!isViewing) return; handleMessage(); if (audioDecoder.state === 'unconfigured') audioDecoder.configure({ codec:'opus', sampleRate:48000, numberOfChannels:1 });
                if(audioDecoder.state === 'configured') audioDecoder.decode(new EncodedAudioChunk({ type:'key', timestamp:msg.timestamp, duration:msg.duration, data:base64ToArrayBuffer(msg.data_base64) }));
            });
        }
        async function stopViewing() {
            isViewing = false; 
            stopViewerPresence(true);
            videoBuffer.forEach(f=>f.close()); audioBuffer.forEach(c=>c.close()); lastRenderedFrame?.close();
            videoBuffer=[]; audioBuffer=[]; lastRenderedFrame=null; canvasWrapper.style.aspectRatio = ''; currentStreamConfigId=null;
            isPlaying = false; isManuallyPaused = false; 
            if (streamHealthInterval) clearInterval(streamHealthInterval);
            lastChunkReceivedTimestamp = 0; statusDot.className = 'status-dot dot-red'; statusDot.title = 'Disconnected';
            detailedWatchStatus = 'Looking for a broadcast...';
            
            broadcasterInfoOnWatchPage.classList.add('hidden');
            broadcasterDisplayName.textContent = '';
            currentBroadcasterAddress = null; // Reset tipping address
            if (tipBtn) tipBtn.disabled = true;

            if (videoSubscription) await videoSubscription.unsubscribe(); if (audioSubscription) await audioSubscription.unsubscribe();
            if (videoDecoder?.state !== 'closed') videoDecoder.close(); if (audioDecoder?.state !== 'closed') audioDecoder.close();
            if(audioContext?.state !== 'closed') await audioContext.close();
            myPartition = null;
        }


        // --- Presence Logic ---
        function updateViewerCountUI(count) {
            viewerCountBroadcasterValue.textContent = count; viewerCountWatcherValue.textContent = count;
            viewerCountBroadcaster.classList.toggle('hidden', count < 0); viewerCountWatcher.classList.toggle('hidden', count < 0);
        }
        async function startBroadcasterPresence() {
            // Unsubscribe from lobby stream if we were subscribed
            if (lobbySubscription) { await lobbySubscription.unsubscribe(); lobbySubscription = null; }

            let viewers = new Map();
            presenceSubscription = await streamrClient.subscribe(getStreamId('presence', myPartition), msg => { 
                if(msg.userId) { 
                    if(msg.type==='join'||msg.type==='heartbeat') viewers.set(msg.userId, Date.now()); 
                    else if (msg.type==='leave') viewers.delete(msg.userId); 
                } 
            });
            broadcasterPresenceInterval = setInterval(async () => {
                const now = Date.now(); for (const [id, seen] of viewers.entries()) if (now-seen > VIEWER_TIMEOUT_MS) viewers.delete(id);
                updateViewerCountUI(viewers.size); 
                const presencePayload = { 
                    type:'stream_update', 
                    partition: myPartition,
                    viewerCount: viewers.size,
                    broadcaster: {
                        publisherId: mySessionId,
                        realAddress: myRealAddress,
                        nickname: myNickname,
                        roomName: myRoomName
                    }
                };
                // Publish to the lobby stream to announce our presence
                await streamrClient.publish(LOBBY_STREAM_ID, presencePayload);
            }, 5000);
        }
        function stopBroadcasterPresence() {
             if (broadcasterPresenceInterval) clearInterval(broadcasterPresenceInterval);
             if (presenceSubscription) presenceSubscription.unsubscribe();
             // Publish a leave message to the lobby stream
             streamrClient.publish(LOBBY_STREAM_ID, { type: 'stream_update', partition: myPartition, viewerCount: 0, broadcaster: null });
             myPartition = null;
             myRoomName = ''; // Clear the room name
             updateViewerCountUI(-1);
        }
        async function startViewerPresence() {
            if (lobbySubscription) { await lobbySubscription.unsubscribe(); lobbySubscription = null; }
            currentUserId = `viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            await streamrClient.publish(getStreamId('presence', myPartition), { type:'join', userId:currentUserId });
            presenceHeartbeatInterval = setInterval(() => streamrClient.publish(getStreamId('presence', myPartition), { type:'heartbeat', userId:currentUserId }), HEARTBEAT_INTERVAL_MS);
            
            presenceSubscription = await streamrClient.subscribe(LOBBY_STREAM_ID, msg => { 
                if (msg.type === 'stream_update' && msg.partition === myPartition) {
                    if(msg.broadcaster) {
                        updateViewerCountUI(msg.viewerCount); 
                        const { publisherId, realAddress, nickname, roomName } = msg.broadcaster;
                        
                        // Store broadcaster address for tipping
                        currentBroadcasterAddress = realAddress || null;

                        if (realAddress) { userRealAddresses.set(publisherId, realAddress); }
                        if (nickname) { userNicknames.set(publisherId, nickname); }
                        if (roomName) { 
                            roomNames.set(myPartition, roomName); 
                            roomNameOnWatchPage.textContent = roomName; // Update the room name on watch page
                        }
                       
                        // Update UI
                        broadcasterDisplayName.innerHTML = `Streaming now: ${getDisplayName(publisherId)}`;
                        if (tipRecipientName) tipRecipientName.innerHTML = getDisplayName(publisherId);
                        broadcasterInfoOnWatchPage.classList.remove('hidden');

                        // Enable/disable tip button
                        if (tipBtn) {
                            const canTip = myRealAddress && currentBroadcasterAddress;
                            tipBtn.disabled = !canTip;
                        }
                        
                        setTimeout(alignAndMatchHeight, 50); // Re-align after content changes
                    } else {
                        // Broadcaster has left
                        broadcasterInfoOnWatchPage.classList.add('hidden');
                        broadcasterDisplayName.textContent = '';
                        currentBroadcasterAddress = null;
                        if (tipBtn) tipBtn.disabled = true;
                        detailedWatchStatus = 'Stream has ended. Returning to lobby...';
                        watchStatus.textContent = detailedWatchStatus;
                        setTimeout(goBackToLobby, 3000); // Go back after a delay
                    }
                }
            });
        }
        function stopViewerPresence(sendLeave = false) {
            if (presenceHeartbeatInterval) clearInterval(presenceHeartbeatInterval); if (presenceSubscription) presenceSubscription.unsubscribe();
            if(sendLeave && currentUserId) streamrClient.publish(getStreamId('presence', myPartition), { type:'leave', userId:currentUserId });
            currentUserId = null; updateViewerCountUI(-1);
            goBackToLobby();
        }

        // --- Tipping Logic ---
        function updateTipModalUI() {
            if (!currentChainId) return;
            const network = NETWORKS[currentChainId];
            if (!network) {
                tipTokenSelect.innerHTML = '<option value="">Unsupported Network</option>';
                return;
            }

            tipTokenSelect.innerHTML = ''; // Clear previous options
            
            // Add native currency
            const nativeOption = document.createElement('option');
            nativeOption.value = 'native';
            nativeOption.textContent = network.symbol;
            tipTokenSelect.appendChild(nativeOption);

            // Add available ERC20 tokens for the network
            const availableTokens = TOKEN_ADDRESSES[currentChainId] || {};
            for (const tokenSymbol in availableTokens) {
                const tokenOption = document.createElement('option');
                tokenOption.value = tokenSymbol;
                tokenOption.textContent = tokenSymbol;
                tipTokenSelect.appendChild(tokenOption);
            }

            // Trigger change event to update the amount label
            tipTokenSelect.dispatchEvent(new Event('change'));
        }

        async function sendTip() {
            if (!currentBroadcasterAddress) {
                tipErrorMsg.textContent = 'Broadcaster address not found.';
                return;
            }

            const amountStr = tipAmountInput.value;
            if (!amountStr || isNaN(amountStr) || parseFloat(amountStr) <= 0) {
                tipErrorMsg.textContent = 'Please enter a valid amount.';
                return;
            }
            tipErrorMsg.textContent = '';

            const selectedToken = tipTokenSelect.value;

            tipInitialView.style.display = 'none';
            tipLoadingView.style.display = 'block';

            try {
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                let tx;

                if (selectedToken === 'native') {
                    // --- NATIVE CURRENCY TRANSFER ---
                    const amountWei = ethers.utils.parseEther(amountStr);
                    tx = await signer.sendTransaction({
                        to: currentBroadcasterAddress,
                        value: amountWei
                    });
                } else {
                    // --- ERC20 TOKEN TRANSFER ---
                    const tokenAddress = TOKEN_ADDRESSES[currentChainId][selectedToken];
                    const tokenDecimals = TOKEN_DECIMALS[selectedToken];
                    if (!tokenAddress || !tokenDecimals) {
                        throw new Error(`Token ${selectedToken} not configured for this network.`);
                    }
                    const amountInSmallestUnit = ethers.utils.parseUnits(amountStr, tokenDecimals);
                    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                    tx = await tokenContract.transfer(currentBroadcasterAddress, amountInSmallestUnit);
                }

                await tx.wait(); // Wait for transaction to be mined

                // --- SEND CHAT NOTIFICATION ---
                const networkName = NETWORKS[currentChainId]?.name || 'the network';
                const tokenSymbol = selectedToken === 'native' ? (NETWORKS[currentChainId]?.symbol || 'coins') : selectedToken;
                const shortTipper = `${myRealAddress.slice(0, 6)}...${myRealAddress.slice(-4)}`;
                const shortRecipient = `${currentBroadcasterAddress.slice(0, 6)}...${currentBroadcasterAddress.slice(-4)}`;
                const tipMessageText = `${shortTipper} tipped ${amountStr} ${tokenSymbol} to ${shortRecipient} via ${networkName}`;
                
                try {
                    await streamrClient.publish(getStreamId('chat', myPartition), { 
                        type: 'tip', 
                        text: tipMessageText,
                        txHash: tx.hash,
                        chainId: currentChainId,
                        realAddress: myRealAddress
                    });
                } catch (err) {
                    console.error("Failed to publish tip notification:", err);
                }

                // --- SHOW SUCCESS ---
                tipLoadingView.style.display = 'none';
                tipSuccessView.style.display = 'block';
                const explorerUrl = NETWORKS[currentChainId]?.explorer;
                if(explorerUrl) {
                    tipEtherscanLink.href = `${explorerUrl}/tx/${tx.hash}`;
                    tipEtherscanLink.style.display = 'inline-block';
                } else {
                    tipEtherscanLink.style.display = 'none';
                }

            } catch (err) {
                console.error("Tipping failed:", err);
                tipLoadingView.style.display = 'none';
                tipInitialView.style.display = 'block';
                let errorMessage = 'Transaction failed.';
                if (err.code === 'ACTION_REJECTED') {
                    errorMessage = 'Transaction rejected in wallet.';
                } else if (err.message.includes('insufficient funds')) {
                    errorMessage = 'Insufficient funds for transaction.';
                }
                tipErrorMsg.textContent = errorMessage;
            }
        }


        // --- Navigation and Cleanup ---
        async function goBackToLobby() {
            // Clean the URL path when returning to the lobby
            if (window.location.pathname !== '/') {
                window.history.pushState({}, document.title, window.location.origin);
            }
            if (isBroadcasting) {
                await stopBroadcast();
                initializeApp();
            } else if (isViewing) {
                await stopViewing();
                initializeApp();
            } else {
                initializeApp();
            }
        }
    </script>
</body>
</html>


