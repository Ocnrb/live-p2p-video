
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Video Streaming with Streamr & WebCodecs</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Streamr Client SDK (Latest Version) -->
    <script src="https://unpkg.com/@streamr/sdk@latest/dist/streamr-sdk.web.js"></script>
    <style>
        /* UI styles from the provided file */
        body { 
            font-family: 'Inter', sans-serif; 
        }
        #localVideo { 
            transform: scaleX(-1); 
            -webkit-transform: scaleX(-1); 
        }
        .page { 
            display: none; 
        }
        .active { 
            display: block; 
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .status-dot {
            height: 10px; 
            width: 10px; 
            border-radius: 50%; 
            display: inline-block;
        }
        .dot-green { background-color: #4ade80; box-shadow: 0 0 5px #4ade80; }
        .dot-red { background-color: #f87171; box-shadow: 0 0 5px #f87171; }
        .dot-yellow { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        .dot-yellow-flashing { animation: pulse-yellow 1.5s infinite; }

        @keyframes pulse-yellow {
            0% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
            50% { background-color: #a16207; box-shadow: none; }
            100% { background-color: #facc15; box-shadow: 0 0 5px #facc15; }
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-moz-range-track {
            background: #3f3f46;
            height: 0.25rem;
            border-radius: 0.5rem;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -6px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            transition: background-color 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            border: none;
            border-radius: 9999px;
            background-color: #a1a1aa;
            height: 1rem;
            width: 1rem;
            transition: background-color 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb { background-color: #d4d4d8; }
        input[type="range"]:hover::-moz-range-thumb { background-color: #d4d4d8; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-zinc-900 text-zinc-300 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl">

        <!-- Main Menu Page -->
        <div id="menu-page" class="page active">
            <div class="text-center">
                <h1 class="text-4xl md:text-5xl font-bold text-white">Decentralized Stream</h1>
                <h2 class="text-4xl md:text-5xl font-bold text-zinc-400 mb-4">Powered by Streamr</h2>
            </div>
            
            <div class="mt-10 bg-zinc-800 border border-zinc-700 rounded-xl p-6 md:p-8">
                <div class="grid md:grid-cols-2 gap-6 text-center">
                    <div class="flex flex-col items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-zinc-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
                        <h3 class="text-xl font-bold text-white mb-4">Broadcast</h3>
                        <button id="go-settings-btn" class="w-full bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Start Broadcasting
                        </button>
                    </div>
                    <div class="flex flex-col items-center">
                       <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-zinc-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                        <h3 class="text-xl font-bold text-white mb-4">Watch</h3>
                        <button id="go-watch-btn" class="w-full bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Watch Stream
                        </button>
                    </div>
                </div>
                 <p id="menu-status" class="text-center text-zinc-500 text-sm mt-6">Connecting to the P2P network...</p>
            </div>
        </div>
        
        <!-- Broadcast Settings Page -->
        <div id="settings-page" class="page">
             <div class="text-center mb-8">
                <h1 class="text-3xl font-bold text-white">Broadcast Settings</h1>
                <p class="text-zinc-400 mt-1">Fine-tune your stream for the best performance.</p>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 rounded-xl p-6 md:p-8 space-y-6 text-left max-w-md mx-auto">
                <div>
                    <label for="videoSourceSelect" class="block mb-2 text-sm font-medium text-zinc-300">Camera</label>
                    <select id="videoSourceSelect" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5"></select>
                </div>
                <div>
                    <label for="audioSourceSelect" class="block mb-2 text-sm font-medium text-zinc-300">Microphone</label>
                    <select id="audioSourceSelect" class="bg-zinc-700 border border-zinc-600 text-white text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block w-full p-2.5"></select>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="resolutionSlider" class="text-sm font-medium text-zinc-300">Resolution</label>
                        <span id="resolutionValue" class="text-sm font-mono text-zinc-400">720p</span>
                    </div>
                    <input id="resolutionSlider" type="range" min="0" max="2" value="1" step="1">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="bitrateSlider" class="text-sm font-medium text-zinc-300">Bitrate</label>
                        <span id="bitrateValue" class="text-sm font-mono text-zinc-400">2.0 Mbps</span>
                    </div>
                    <input id="bitrateSlider" type="range" min="500000" max="5000000" value="2000000" step="100000">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="framerateSlider" class="text-sm font-medium text-zinc-300">Frame Rate</label>
                        <span id="framerateValue" class="text-sm font-mono text-zinc-400">30 fps</span>
                    </div>
                    <input id="framerateSlider" type="range" min="15" max="60" value="30" step="1">
                </div>
            </div>
            <div class="mt-8 flex justify-center gap-4">
                <button id="back-to-menu-settings" class="bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Back</button>
                <button id="start-broadcast-btn" class="bg-zinc-700 hover:bg-zinc-600 text-white font-bold py-2 px-5 rounded-lg transition-colors">Start Broadcasting</button>
            </div>
        </div>

        <!-- Broadcast Page -->
        <div id="broadcast-page" class="page">
             <div class="text-center mb-6">
                <h1 class="text-3xl font-bold text-white">Broadcasting</h1>
                <div class="flex items-center justify-center gap-4 mt-1 text-zinc-400 text-sm">
                    <div id="broadcast-status">...</div>
                    <div id="viewer-count-broadcaster" class="flex items-center gap-1 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                        <span id="viewer-count-broadcaster-value">0</span>
                    </div>
                </div>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                <video id="localVideo" autoplay playsinline muted class="w-full h-auto bg-black rounded-md"></video>
            </div>
            <button id="back-to-menu-broadcast" class="mt-8 bg-zinc-600 hover:bg-zinc-500 text-white font-bold py-2 px-5 rounded-lg transition-colors">Stop and Go Back</button>
        </div>

        <!-- Watch Page -->
        <div id="watch-page" class="page">
            <div class="text-center mb-6">
                 <h1 class="text-3xl font-bold text-white">Watching Stream</h1>
                 <div class="flex items-center justify-center gap-4 mt-1 text-zinc-400 text-sm">
                    <div id="watch-status">...</div>
                    <div id="viewer-count-watcher" class="flex items-center gap-1 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                        <span id="viewer-count-watcher-value">0</span>
                    </div>
                 </div>
            </div>
            <div class="bg-zinc-800 border border-zinc-700 p-4 rounded-xl shadow-lg">
                <div class="relative group">
                    <canvas id="remoteCanvas" class="w-full h-auto bg-black rounded-md"></canvas>
                    <div class="absolute top-2 right-2 bg-zinc-900/50 backdrop-blur-sm rounded-full p-2">
                        <span id="statusDot" class="status-dot dot-red" title="Disconnected"></span>
                    </div>
                    <div class="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                         <button id="fullscreen-btn" class="p-2 rounded-full bg-zinc-900/50 hover:bg-zinc-700/70 transition-colors" title="Fullscreen">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="mt-4 flex justify-between items-center gap-4 px-2">
                    <button id="back-to-menu-watch" class="p-2 rounded-full bg-zinc-700 hover:bg-zinc-600 transition-colors" title="Stop and Go Back">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div class="flex items-center gap-2 flex-grow">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-zinc-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" clip-rule="evenodd" />
                        </svg>
                        <input id="volume-slider" type="range" min="0" max="100" value="100" class="w-full">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const STREAM_BASE = '0xd5a8024414f59cf0c453c35fc3655a31251645f6';
        const VIDEO_STREAM_ID = `${STREAM_BASE}/app5`;
        const AUDIO_STREAM_ID = `${STREAM_BASE}/app6`;
        const PRESENCE_STREAM_ID = `${STREAM_BASE}/app2`;
        
        // --- UI Elements ---
        const pages = {
            menu: document.getElementById('menu-page'),
            settings: document.getElementById('settings-page'),
            broadcast: document.getElementById('broadcast-page'),
            watch: document.getElementById('watch-page'),
        };
        const goSettingsBtn = document.getElementById('go-settings-btn');
        const goWatchBtn = document.getElementById('go-watch-btn');
        const startBroadcastBtn = document.getElementById('start-broadcast-btn');
        const backBtns = [
            document.getElementById('back-to-menu-broadcast'),
            document.getElementById('back-to-menu-watch'),
            document.getElementById('back-to-menu-settings'),
        ];
        
        const localVideo = document.getElementById('localVideo');
        const remoteCanvas = document.getElementById('remoteCanvas');
        const broadcastStatus = document.getElementById('broadcast-status');
        const watchStatus = document.getElementById('watch-status');
        const statusDot = document.getElementById('statusDot');
        const menuStatus = document.getElementById('menu-status');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        
        const viewerCountBroadcaster = document.getElementById('viewer-count-broadcaster');
        const viewerCountBroadcasterValue = document.getElementById('viewer-count-broadcaster-value');
        const viewerCountWatcher = document.getElementById('viewer-count-watcher');
        const viewerCountWatcherValue = document.getElementById('viewer-count-watcher-value');

        const videoSourceSelect = document.getElementById('videoSourceSelect');
        const audioSourceSelect = document.getElementById('audioSourceSelect');
        const resolutionSlider = document.getElementById('resolutionSlider');
        const resolutionValue = document.getElementById('resolutionValue');
        const bitrateSlider = document.getElementById('bitrateSlider');
        const bitrateValue = document.getElementById('bitrateValue');
        const framerateSlider = document.getElementById('framerateSlider');
        const framerateValue = document.getElementById('framerateValue');
        const volumeSlider = document.getElementById('volume-slider');
        
        const canvasContext = remoteCanvas.getContext('2d');

        // --- Constants and Mappings ---
        const resolutions = [
            { text: '480p', value: '640x480' },
            { text: '720p', value: '1280x720' },
            { text: '1080p', value: '1920x1080' }
        ];

        // --- State Variables ---
        let streamrClient;
        let videoEncoder, audioEncoder;
        let videoDecoder, audioDecoder;
        let localStream;
        let audioContext, gainNode;
        let videoSubscription, audioSubscription, presenceSubscription;
        let isBroadcasting = false;
        let isViewing = false;
        let lastKeyFrameTimestamp = 0;
        const KEY_FRAME_INTERVAL_MS = 2000;
        let lastChunkReceivedTimestamp = 0;
        let streamHealthInterval = null;
        const STALE_STREAM_TIMEOUT_MS = 3000;
        
        // Presence state
        let currentUserId = null;
        let viewers = new Map();
        let presenceHeartbeatInterval = null;
        let broadcasterPresenceInterval = null;
        const VIEWER_TIMEOUT_MS = 15000; // 15 seconds
        const HEARTBEAT_INTERVAL_MS = 10000; // 10 seconds

        // Viewer state
        let detailedWatchStatus = 'Looking for a broadcast...';


        // --- Helper Functions ---
        function showPage(pageName) {
            Object.values(pages).forEach(p => p.classList.remove('active'));
            if(pages[pageName]) pages[pageName].classList.add('active');
        }

        async function populateDeviceLists() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                videoSourceSelect.innerHTML = '';
                audioSourceSelect.innerHTML = '';
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    if (device.kind === 'videoinput') {
                        option.text = device.label || `Camera ${videoSourceSelect.length + 1}`;
                        videoSourceSelect.appendChild(option);
                    } else if (device.kind === 'audioinput') {
                        option.text = device.label || `Microphone ${audioSourceSelect.length + 1}`;
                        audioSourceSelect.appendChild(option);
                    }
                });
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                tempStream.getTracks().forEach(track => track.stop());
            } catch (err) {
                alert(`Error getting media devices: ${err.message}. Please check permissions.`);
                showPage('menu');
            }
        }
        
        // --- Event Listeners for Sliders ---
        resolutionSlider.addEventListener('input', (e) => {
            resolutionValue.textContent = resolutions[e.target.value].text;
        });
        bitrateSlider.addEventListener('input', (e) => {
            bitrateValue.textContent = `${(e.target.value / 1000000).toFixed(1)} Mbps`;
        });
        framerateSlider.addEventListener('input', (e) => {
            framerateValue.textContent = `${e.target.value} fps`;
        });
        volumeSlider.addEventListener('input', (e) => {
            if (gainNode) {
                gainNode.gain.setValueAtTime(e.target.value / 100, audioContext.currentTime);
            }
        });


        // --- Core Logic ---
        document.addEventListener('DOMContentLoaded', async () => {
            menuStatus.textContent = 'Connecting to the P2P network...';
            try {
                streamrClient = new StreamrClient();
                await streamrClient.connect();
                menuStatus.textContent = 'Ready. Choose an option.';
             //   goSettingsBtn.disabled = false;
                goWatchBtn.disabled = false;
            } catch (error) {
                console.error('Failed to initialize Streamr client:', error);
                menuStatus.textContent = `Error connecting: ${error.message}. Please refresh.`;
            }
        });

        // --- Broadcaster ---
        async function startBroadcast() {
            if (!('VideoEncoder' in window && 'AudioEncoder' in window)) {
                alert('Error: WebCodecs API not supported in this browser.');
                return;
            }
            showPage('broadcast');
            isBroadcasting = true;
            startBroadcasterPresence();

            const resolution = resolutions[resolutionSlider.value].value;
            const [width, height] = resolution.split('x').map(Number);
            const bitrate = parseInt(bitrateSlider.value, 10);
            const framerate = parseInt(framerateSlider.value, 10);
            const videoDeviceId = videoSourceSelect.value;
            const audioDeviceId = audioSourceSelect.value;

            try {
                const statusText = `Broadcasting: ${width}x${height} @ ${framerate}fps, ~${(bitrate / 1000000).toFixed(1)}Mbps`;
                broadcastStatus.textContent = statusText;

                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { deviceId: { exact: videoDeviceId }, width, height, frameRate: { ideal: framerate, max: framerate } },
                    audio: { deviceId: { exact: audioDeviceId }, echoCancellation: true, noiseSuppression: true }
                });
                localVideo.srcObject = localStream;
                
                const videoTrack = localStream.getVideoTracks()[0];
                const videoProcessor = new MediaStreamTrackProcessor({ track: videoTrack });
                const videoFrameReader = videoProcessor.readable.getReader();
                let videoConfig;

                videoEncoder = new VideoEncoder({
                    output: async (chunk, metadata) => {
                        if (metadata.decoderConfig) videoConfig = metadata.decoderConfig;
                        if (!videoConfig || !isBroadcasting) return;
                        const chunkData = new Uint8Array(chunk.byteLength);
                        chunk.copyTo(chunkData);
                        const message = {
                            chunk_type: chunk.type, timestamp: chunk.timestamp, duration: chunk.duration,
                            data: Array.from(chunkData)
                        };
                        if (chunk.type === 'key') {
                            const serializableConfig = { ...videoConfig };
                            if (serializableConfig.description) {
                                serializableConfig.description = Array.from(new Uint8Array(serializableConfig.description));
                            }
                            serializableConfig.streamSettings = { width, height, framerate, bitrate };
                            message.config = serializableConfig;
                        }
                        await streamrClient.publish(VIDEO_STREAM_ID, message);
                    },
                    error: e => console.error(`VideoEncoder Error: ${e.message}`)
                });
                const vConfig = { codec: 'avc1.64002A', width, height, bitrate, framerate, hardwareAcceleration: 'prefer-hardware' };
                await videoEncoder.configure(vConfig);

                const audioTrack = localStream.getAudioTracks()[0];
                const audioProcessor = new MediaStreamTrackProcessor({ track: audioTrack });
                const audioFrameReader = audioProcessor.readable.getReader();

                audioEncoder = new AudioEncoder({
                    output: async (chunk) => {
                         if (!isBroadcasting) return;
                        const chunkData = new Uint8Array(chunk.byteLength);
                        chunk.copyTo(chunkData);
                        const message = {
                            timestamp: chunk.timestamp, duration: chunk.duration,
                            data: Array.from(chunkData)
                        };
                        await streamrClient.publish(AUDIO_STREAM_ID, message);
                    },
                    error: e => console.error(`AudioEncoder Error: ${e.message}`)
                });
                const aConfig = { codec: 'opus', sampleRate: 48000, numberOfChannels: 1, bitrate: 64000 };
                await audioEncoder.configure(aConfig);

                const readVideoFrames = async () => {
                    while (isBroadcasting) {
                        const { value: frame, done } = await videoFrameReader.read().catch(() => ({ done: true }));
                        if (done) break;
                        const forceKeyFrame = (Date.now() - lastKeyFrameTimestamp) > KEY_FRAME_INTERVAL_MS;
                        if(forceKeyFrame) lastKeyFrameTimestamp = Date.now();
                        if (videoEncoder.state === 'configured') videoEncoder.encode(frame, { keyFrame: forceKeyFrame });
                        frame.close();
                    }
                };
                const readAudioFrames = async () => {
                    while (isBroadcasting) {
                        const { value: frame, done } = await audioFrameReader.read().catch(() => ({ done: true }));
                        if (done) break;
                        if (audioEncoder.state === 'configured') audioEncoder.encode(frame);
                        frame.close();
                    }
                };
                readVideoFrames();
                readAudioFrames();

            } catch (error) {
                console.error(`Broadcast start error: ${error.message}`);
                alert(`Error starting broadcast: ${error.message}`);
                goBackToMenu();
            }
        }
        
        async function stopBroadcast() {
            isBroadcasting = false;
            stopBroadcasterPresence();
            if(localStream) localStream.getTracks().forEach(track => track.stop());
            if(videoEncoder?.state !== 'closed') videoEncoder.close();
            if(audioEncoder?.state !== 'closed') audioEncoder.close();
            localVideo.srcObject = null;
        }

        // --- Viewer ---
        function checkStreamHealth() {
            if (isViewing && lastChunkReceivedTimestamp > 0 && (Date.now() - lastChunkReceivedTimestamp > STALE_STREAM_TIMEOUT_MS)) {
                if (!statusDot.classList.contains('dot-yellow-flashing')) {
                    statusDot.className = 'status-dot dot-yellow-flashing';
                    statusDot.title = 'Connection unstable';
                    watchStatus.textContent = 'Connection unstable...';
                }
            }
        }
        
        async function joinStream() {
            if (!('VideoDecoder' in window && 'AudioDecoder' in window)) {
                alert('Error: WebCodecs API not supported on this browser.');
                return;
            }
            showPage('watch');
            isViewing = true;
            startViewerPresence();
            watchStatus.textContent = detailedWatchStatus;
            statusDot.className = 'status-dot dot-yellow';
            statusDot.title = 'Connecting...';

            streamHealthInterval = setInterval(checkStreamHealth, 1000);

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            await audioContext.resume();
            
            gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volumeSlider.value / 100, audioContext.currentTime);
            gainNode.connect(audioContext.destination);

            videoDecoder = new VideoDecoder({
                output: (frame) => {
                    canvasContext.drawImage(frame, 0, 0, remoteCanvas.width, remoteCanvas.height);
                    frame.close();
                },
                error: e => console.error(`VideoDecoder Error: ${e.message}`)
            });

            audioDecoder = new AudioDecoder({
                output: (audioData) => {
                    try {
                        const buffer = audioContext.createBuffer(audioData.numberOfChannels, audioData.numberOfFrames, audioData.sampleRate);
                        for (let i = 0; i < audioData.numberOfChannels; i++) {
                            const channelData = new Float32Array(audioData.numberOfFrames);
                            audioData.copyTo(channelData, { planeIndex: i });
                            buffer.copyToChannel(channelData, i);
                        }
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        source.connect(gainNode);
                        source.start();
                    } catch (e) {
                         console.error("Error playing audio data:", e);
                    }
                },
                error: e => console.error(`AudioDecoder Error: ${e.message}`)
            });

            const handleMessage = () => {
                lastChunkReceivedTimestamp = Date.now();
                if (statusDot.classList.contains('dot-yellow-flashing')) {
                     statusDot.className = 'status-dot dot-green';
                     statusDot.title = 'Connected';
                     watchStatus.textContent = detailedWatchStatus;
                }
            };

            videoSubscription = await streamrClient.subscribe(VIDEO_STREAM_ID, (message) => {
                if (!isViewing) return;
                handleMessage();
                const chunk = new EncodedVideoChunk({
                    type: message.chunk_type, timestamp: message.timestamp, duration: message.duration,
                    data: new Uint8Array(message.data).buffer
                });
                if (message.config && videoDecoder.state === 'unconfigured') {
                    const config = message.config;
                    remoteCanvas.width = config.codedWidth;
                    remoteCanvas.height = config.codedHeight;
                    
                    if (config.streamSettings) {
                        const s = config.streamSettings;
                        detailedWatchStatus = `Receiving: ${s.width}x${s.height} @ ${s.framerate}fps, ~${(s.bitrate / 1000000).toFixed(1)}Mbps`;
                    } else {
                        detailedWatchStatus = `Receiving: ${config.codedWidth}x${config.codedHeight}`;
                    }
                    watchStatus.textContent = detailedWatchStatus;

                    if (config.description) config.description = new Uint8Array(config.description).buffer;
                    videoDecoder.configure(config);
                    
                    statusDot.className = 'status-dot dot-green';
                    statusDot.title = 'Connected';
                }
                if (videoDecoder.state === 'configured') videoDecoder.decode(chunk);
            });

            audioSubscription = await streamrClient.subscribe(AUDIO_STREAM_ID, (message) => {
                if (!isViewing) return;
                handleMessage();
                if (audioDecoder.state === 'unconfigured') {
                     audioDecoder.configure({ codec: 'opus', sampleRate: 48000, numberOfChannels: 1 });
                }
                const chunk = new EncodedAudioChunk({
                    type: 'key', timestamp: message.timestamp, duration: message.duration,
                    data: new Uint8Array(message.data).buffer
                });
                if(audioDecoder.state === 'configured') audioDecoder.decode(chunk);
            });
        }
        
        async function stopViewing() {
            isViewing = false;
            stopViewerPresence(true);

            if (streamHealthInterval) clearInterval(streamHealthInterval);
            streamHealthInterval = null;
            lastChunkReceivedTimestamp = 0;
            statusDot.className = 'status-dot dot-red';
            statusDot.title = 'Disconnected';
            detailedWatchStatus = 'Looking for a broadcast...';
            
            if (videoSubscription) await videoSubscription.unsubscribe();
            if (audioSubscription) await audioSubscription.unsubscribe();
            videoSubscription = null;
            audioSubscription = null;

            if(videoDecoder?.state !== 'closed') videoDecoder.close();
            if(audioDecoder?.state !== 'closed') audioDecoder.close();
            if(audioContext?.state !== 'closed') await audioContext.close();
        }

        // --- Presence Logic ---
        function updateViewerCountUI(count) {
            viewerCountBroadcasterValue.textContent = count;
            viewerCountWatcherValue.textContent = count;
            viewerCountBroadcaster.classList.toggle('hidden', count < 0);
            viewerCountWatcher.classList.toggle('hidden', count < 0);
        }

        async function startBroadcasterPresence() {
            presenceSubscription = await streamrClient.subscribe(PRESENCE_STREAM_ID, (message) => {
                if(message.userId) {
                    if(message.type === 'join' || message.type === 'heartbeat') {
                        viewers.set(message.userId, Date.now());
                    } else if (message.type === 'leave') {
                        viewers.delete(message.userId);
                    }
                }
            });

            broadcasterPresenceInterval = setInterval(async () => {
                const now = Date.now();
                let changed = false;
                for (const [userId, lastSeen] of viewers.entries()) {
                    if (now - lastSeen > VIEWER_TIMEOUT_MS) {
                        viewers.delete(userId);
                        changed = true;
                    }
                }
                const count = viewers.size;
                updateViewerCountUI(count);
                // Publish count only if it changes or periodically
                await streamrClient.publish(PRESENCE_STREAM_ID, { type: 'viewer_count_update', count });

            }, 5000); // Check every 5 seconds
        }

        function stopBroadcasterPresence() {
             if (broadcasterPresenceInterval) clearInterval(broadcasterPresenceInterval);
             if (presenceSubscription) presenceSubscription.unsubscribe();
             broadcasterPresenceInterval = null;
             presenceSubscription = null;
             viewers.clear();
             updateViewerCountUI(-1);
        }

        async function startViewerPresence() {
            currentUserId = `viewer-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            await streamrClient.publish(PRESENCE_STREAM_ID, { type: 'join', userId: currentUserId });

            presenceHeartbeatInterval = setInterval(() => {
                 streamrClient.publish(PRESENCE_STREAM_ID, { type: 'heartbeat', userId: currentUserId });
            }, HEARTBEAT_INTERVAL_MS);

            presenceSubscription = await streamrClient.subscribe(PRESENCE_STREAM_ID, (message) => {
                if (message.type === 'viewer_count_update') {
                    updateViewerCountUI(message.count);
                }
            });
        }
        
        function stopViewerPresence(shouldSendLeave = false) {
            if (presenceHeartbeatInterval) clearInterval(presenceHeartbeatInterval);
            if (presenceSubscription) presenceSubscription.unsubscribe();
            presenceHeartbeatInterval = null;
            presenceSubscription = null;
            if(shouldSendLeave && currentUserId) {
                streamrClient.publish(PRESENCE_STREAM_ID, { type: 'leave', userId: currentUserId });
            }
            currentUserId = null;
            updateViewerCountUI(-1);
        }
        
        // --- Navigation and Cleanup ---
        async function goBackToMenu() {
            if (isBroadcasting) await stopBroadcast();
            if (isViewing) await stopViewing();
            showPage('menu');
        }

        function handleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                remoteCanvas.requestFullscreen().catch(err => {
                    alert(`Fullscreen Error: ${err.message}`);
                });
            }
        }
        
        goSettingsBtn.onclick = async () => {
            await populateDeviceLists();
            showPage('settings');
        };
        goWatchBtn.onclick = joinStream;
        startBroadcastBtn.onclick = startBroadcast;
        backBtns.forEach(btn => btn.onclick = goBackToMenu);
        fullscreenBtn.onclick = handleFullscreen;

        window.addEventListener('beforeunload', () => {
             if(isViewing && currentUserId) {
                 streamrClient.publish(PRESENCE_STREAM_ID, { type: 'leave', userId: currentUserId });
             }
        });

    </script>
</body>
</html>
